# Note 17

<BackTop />

## 为什么 `js` 中 `0.1 + 0.2 !== 0.3`？

在 `JavaScript` 中，`0.1 + 0.2 !== 0.3` 的根本原因是计算机使用 **二进制浮点数表示法**（遵循 IEEE 754 标准）导致的精度丢失问题。以下是详细的解释：

### 一、浮点数的二进制表示

计算机用二进制存储数字，而许多十进制小数无法精确转换为二进制。例如：

- **0.1（十进制）** 转换为二进制是 `0.00011001100110011...`（无限循环）。
- **0.2（十进制）** 转换为二进制是 `0.0011001100110011...`（无限循环）。

这些无限循环的二进制小数在存储时会被 **截断** 或 **舍入**，导致精度丢失。

### 二、IEEE 754 双精度浮点数

`JavaScript` 使用 **64位双精度浮点数**（Double-precision floating-point）存储数值，其结构为：

- **1位符号位**：表示正负。
- **11位指数位**：决定数值的范围。
- **52位尾数位**：存储有效数字（二进制小数部分）。

由于尾数位有限（52位），当十进制小数转换为二进制后长度超过 `52` 位时，会 **舍入到最近的近似值**，从而引发精度误差。

### 三、0.1 + 0.2 的计算过程

1. **存储近似值**：
   - `0.1` 的二进制近似值在计算机中存储为 `0.10000000000000000555...`。
   - `0.2` 的二进制近似值存储为 `0.20000000000000001110...`。
2. **加法运算**：
   - 二进制加法后的结果约为 `0.30000000000000004440...`。
3. **十进制转换**：
   - 最终的十进制结果近似为 `0.30000000000000004`，因此 `0.1 + 0.2 !== 0.3`。

### 四、验证与解决方案

#### 1. 验证精度问题

```js
console.log(0.1 + 0.2) // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3) // false
```

#### 2. 解决方案

- **方法一：容忍微小误差**
  使用一个极小的误差范围（如 `Number.EPSILON`）比较结果：

  ```js
  function isEqual(a, b) {
    return Math.abs(a - b) < Number.EPSILON
  }
  console.log(isEqual(0.1 + 0.2, 0.3)) // true
  ```

- **方法二：转为整数运算**
  将小数转换为整数计算后再还原：

  ```js
  const result = (0.1 * 10 + 0.2 * 10) / 10 // 0.3
  console.log(result === 0.3) // true
  ```

- **方法三：使用 `toFixed`（需谨慎）**
  截断小数位数（注意 `toFixed` 可能四舍五入）：

  ```js
  const sum = (0.1 + 0.2).toFixed(1) // "0.3"
  console.log(parseFloat(sum) === 0.3) // true
  ```

- **方法四：使用高精度库**  
  如 `decimal.js` 或 `big.js` 处理精确计算：

  ```js
  import { Decimal } from "decimal.js"
  const sum = new Decimal(0.1).add(0.2).toNumber()
  console.log(sum === 0.3) // true
  ```

### 五、这不是 JavaScript 的“缺陷”！

- **所有遵循 IEEE 754 的语言都有此问题**（如 Python、Java、C++）。
- **这是二进制浮点数的固有特性**，与语言无关。
- **整数计算不会出现此问题**（例如 `0.5 + 0.5 === 1`，因为 `0.5` 是二进制有限小数）。

### 总结

`0.1 + 0.2 !== 0.3` 的原因是：

1. 十进制小数转换为二进制时丢失精度。
2. 浮点数的存储和计算基于近似值。
3. 误差在运算过程中被放大。

理解这一机制后，可以通过数学方法或第三方库规避精度问题。
