# Note 6

## Vue Router 中 `hash` 和 `history` 模式的区别

# Vue Router 中 Hash 和 History 模式的区别

在 `Vue Router` 中，有两种路由模式：**hash** 和 **history**。它们有不同的工作原理、优缺点和适用场景。

## 核心区别

| 特性 | `Hash` 模式 | `History` 模式 |
|------|-----------|--------------|
| `URL` 格式 | `http://example.com/#/path` | `http://example.com/path` |
| 服务器配置 | 不需要特殊配置 | 需要配置支持 |
| `SEO` 友好性 | 较差 | 较好 |
| 兼容性 | 所有浏览器 | 需要 `HTML5 History API` 支持 |
| 实现原理 | 使用 `URL hash` 部分 | 使用 `History API` |

## 详细解析

### Hash 模式

- 使用 `URL` 的 `hash`（`#`）部分来模拟路由
- 当 `hash` 改变时，浏览器不会向服务器发送请求
- 完全在客户端处理路由

```javascript
// 配置
const router = new VueRouter({
  mode: 'hash',
  routes: [...]
})
```

### History 模式

- 使用 `HTML5 History API` 实现
- `URL` 看起来更自然，没有 `#` 符号
- 需要服务器端配置支持，否则刷新页面会出现 `404`

```javascript
// 配置
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

## 使用建议

1. **使用 Hash 模式的情况**：
   - 不需要 `SEO` 支持
   - 没有服务器配置权限
   - 需要兼容旧版浏览器

2. **使用 History 模式的情况**：
   - 需要 `SEO` 友好的 `URL`
   - 有服务器配置权限
   - 目标用户使用现代浏览器

## 服务器配置示例

对于 `History` 模式，服务器需要配置以支持直接访问路由：

### Nginx 配置

```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

### Node.js (Express) 配置

```javascript
const history = require('connect-history-api-fallback');
app.use(history());
```

## 单点登录 `SSO`(Single Sign-On)

### 1. `session` + `cookie` 模式

用户登录时，子系统会将用户引导到认证中心去登录，账号密码验证通过后，建立（已有）一个 `session` 表格，一个键值对，`key` 对应生成的唯一 `sessionID`，`value` 是他对应的身份信息，每个键值对有一个过期时间，到期自动清除，该表格通常存储到 `redis` 数据库，同时将 `sessionID` 下发给用户，用户进行保存，登录完成。
当用户携带 `sessionID` 登录子系统时，子系统会请求认证中心去进行验证，认证中心去查询是否存在对应的键值对，有就返回用户信息给子系统，没有就是未登录或登录已过期

- 优点：有强控制力，比如：某天需要让某个用户或者某一批用户下线，只需要删除这些用户在表格中对应的键值对即可
- 缺点：所有的子系统每次请求都需要发起认证请求，每天需要接送非常大量的请求，需要做服务器集群，扩容，总体成本高，另外如果子系统扩容，认证中心也需要跟着扩容，成本高（大公司无所谓成本只在乎强控制力，中小型公司更在乎成本，牺牲强控制力）

### 2. `token` 模式（分布式的认证模式）

没有服务器键值对表格，首先到认证中心登录，认证中心验证没问题后不会保存任何信息，只会生成一个不可被篡改的 `token`，格式一般来说是 `JWT`（无法被篡改），然后认证中心会将 `token` 发送给用户，用户自行保存，然后当用户访问子系统时，用户携带该 `token`，子系统独立验证该 `token`，（验证方式比如，子系统与认证中心交换一个密钥，通过这个密钥自行去验证用户 `token`）。
此时，如果子系统需要扩容，则认证系统无需扩容，所以会说 `token` 模式是一种分布式的认证模式，即子系统自行认证。认证中心只管颁发，子系统只管认证，认证中心压力小

- 优点：成本低
- 缺点：认证中心对用户的控制力弱，无法让用户立即下线，因为 `token` 还被用户保存着。

### 3. 双 token 模式

`token` 模式未解决这种对用户控制力弱的问题，于是考虑采用折中的双 `token` 模式，用户去认证中心登录认证，认证成功后，认证中心返回两个 `token`，一个过期时间短的请求 `token`（`10min` 或 `20min` 等），一个过期时间长的刷新 `token`，当用户访问子系统时，只需携带过期时间短的 `token`，而子系统只需去验证请求 `token` 即可，当该 `token` 过期后，用户只需携带刷新 `token` 去认证中心换取请求 `token`（即每隔一段时间需要来认证中心认证一次，方便认证中心的控制）
