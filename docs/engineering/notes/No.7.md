# Note 7

## 前端打包对于图片资源是否需要进行 gzip/br 压缩

**通常情况下，不需要也不应该对已经压缩过的图片格式（如 `JPEG`, `PNG`, `WebP`, `AVIF`）进行 `Gzip` 或 `Brotli` 压缩。**

### 为什么不需要？主要原因有三点：

1. **收益极低，甚至可能适得其反**
    * **工作原理**：`Gzip` 和 `Brotli` 这类压缩算法主要针对**文本内容**进行优化。它们通过查找和替换重复的字符串模式来减小文件大小。
    * **图片的本质**：像 `JPEG`、`PNG` 这类常见的图片格式，其本身就是**已经压缩过的二进制格式**。它们使用了各自的压缩算法（如 `JPEG` 的有损压缩，`PNG` 的无损压缩）来尽可能减少文件大小。图片文件中的数据（尤其是照片类 `JPEG`）已经非常随机，几乎没有可供 `Gzip`/`Brotli` 再次压缩的重复模式。
    * **结果**：试图对它们进行二次压缩，压缩率会非常低（通常只有 `2%-5%` 的缩小），有时甚至因为压缩文件头等元数据的增加，导致压缩后的文件比原文件**更大**。这个过程浪费了服务器 `CPU` 资源，却几乎没有换来任何带宽节省。

2. **浪费服务器和客户端资源**
    * **服务器 CPU**：服务器需要对每个请求的图片资源进行实时压缩（如果配置了动态压缩），或者需要预先存储压缩后的版本。这对于大量图片的网站来说，是一笔不小的 `CPU` 开销。
    * **客户端 CPU**：浏览器在下载完成后，需要解压这些资源才能渲染。虽然现代设备解压很快，但这个不必要的步骤仍然会消耗设备电量，并在极端情况下可能略微延迟图片的渲染时间。

3. **现代图片格式已经足够优秀**
    * 现在主流的现代图片格式，如 **WebP** 和 **AVIF**，相比传统的 `JPEG` 和 `PNG`，在同等质量下拥有更小的文件体积。将精力放在**将图片转换为现代格式**上，其收益远远大于对旧格式进行 `Gzip/Brotli` 压缩。

### 什么时候需要对“图片”进行 `Gzip/Brotli` 压缩？

<br/>

有一个重要的例外情况：**对 `SVG` 格式的图片进行压缩。**

**为什么 `SVG` 需要压缩？**

* **SVG 的本质**：`SVG（Scalable Vector Graphics）`文件本身是 **XML 格式的文本文件**。它里面包含的是标签、路径数据、样式等文本信息，这些信息有很多重复的模式（例如大量的 `<path>` 标签、重复的样式定义等）。
* **高压缩率**：正因为它是文本，所以 `Gzip` 或 `Brotli` 对其压缩效果非常显著，通常可以减少 **50% - 80%** 的体积。这对于复杂的 `SVG` 图标或插图来说是巨大的性能提升。

**最佳实践建议：**

* 在 `Nginx` 或 `Apache` 等服务器的配置中，确保将 `SVG` 文件包含在需要压缩的 `MIME` 类型中。
* 例如在 `Nginx` 中：

  ```nginx
  gzip_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/javascript
    application/xml+rss
    application/json
    image/svg+xml; # 确保包含这一行！
  ```

### 总结与最佳实践

| 资源类型 | 推荐使用 `Gzip/Brotli` | 原因 |
| :--- | :--- | :--- |
| **HTML, CSS, JS, JSON** | **强烈推荐** | 文本文件，包含大量重复模式，压缩效果极佳。 |
| **SVG 图片** | **强烈推荐** | 本质是 `XML` 文本，压缩率非常高。 |
| **JPEG, PNG, GIF** | **不推荐** | 已是压缩过的二进制格式，二次压缩收益极低，浪费资源。 |
| **WebP, AVIF** | **不推荐** | 采用更先进的压缩算法，已是压缩后的最佳状态。 |

**所以，对于前端项目打包后的图片资源，你应该做的是：**

1.  **格式优化**：将项目中的 `JPEG`、`PNG` 图片转换为 **WebP** 格式。现在浏览器支持度已经非常广，能带来显著的体积减小。
2.  **质量调整**：根据使用场景（如大图展示 vs. 小图标），适当降低图片的输出质量。
3.  **尺寸适配**：根据不同的设备和屏幕尺寸，输出不同尺寸的图片（响应式图片，使用 `srcset` 和 `sizes` 属性）。
4.  **压缩 SVG**：确保你的构建流程或服务器对 `SVG` 文件启用了 `Brotli`（优先）或 `Gzip` 压缩。
5.  **CDN 与缓存**：使用 `CDN` 并配置正确的缓存策略，这比压缩图片本身带来的性能提升可能更大。

通过以上这些方法，你可以更高效地优化前端项目中的图片资源，而不是在效果甚微的 `Gzip/Brotli` 压缩上浪费时间。

## 静态资源是否需要全部放到 CDN 上？

**静态资源不需要，也不应该“全部”放到`CDN`上。** 这是一个需要根据资源类型、业务需求、成本和架构进行权衡的决策。

### 为什么需要把大部分静态资源放到CDN上？（放CDN的好处）

<br/>

将**主要的、公共的**静态资源（如`JS`、`CSS`、图片、字体、视频）放到`CDN`上，主要是为了：

1. **极致性能，降低延迟**
    * **就近访问**：`CDN`在全球分布有多个边缘节点，用户可以从地理上最近的节点获取资源，极大减少网络传输的延迟。
    * **缓存命中**：热门资源会被缓存在各个边缘节点，用户请求无需回源，直接命中缓存，速度极快。

2. **减轻源站服务器负载**
    * 静态资源请求占据了网站流量的绝大部分。将这些请求分流到`CDN`，可以显著减少源站服务器的带宽、`CPU`和连接数压力，让源站更专注于处理动态API请求。

3. **提升可用性和容灾能力**
    * 即使源站服务器因故障暂时宕机，用户仍然可以从`CDN`缓存中获取已缓存的静态资源，网站至少可以部分访问（虽然动态功能会失效）。
    * `CDN`本身具备高可用和负载均衡能力，能抵御一定程度的流量冲击（如热点事件、`DDoS`攻击的一部分）。

4. **优化带宽成本**
    * `CDN`厂商的带宽单价通常比你自己购买云服务器带宽要便宜。对于流量巨大的网站，使用`CDN`能节省可观的带宽费用。

### 不放CDN时有什么问题？

<br/>

如果不使用`CDN`，所有静态资源都直接从你的**源站服务器**提供，会面临：

1. **用户体验差**：对于远离你机房的用户，加载速度会明显变慢，首屏时间变长。
2. **服务器压力大**：所有静态资源请求都直接打到源站，容易在流量高峰时成为性能瓶颈，导致服务器响应变慢甚至崩溃。
3. **单点故障风险**：源站成为唯一的出入口，一旦出现问题，整个网站完全无法访问。
4. **成本可能更高**：为了应对峰值流量，你可能需要购买更高配置的服务器和更昂贵的带宽，但大部分时间这些资源是闲置的。

### 全放CDN上又有什么问题？（不放CDN的“反向”问题）

<br/>

把**所有**静态资源，不加区分地都放到`CDN`上，也会引入新的问题：

1. **架构复杂性和运维成本**
    * **缓存策略复杂**：你需要为不同类型的资源（如长期不变的`JS`/`CSS`、频繁更新的商品图、敏感文件）配置不同的缓存过期时间、缓存键规则。
    * **刷新失效挑战**：当资源更新时，你需要手动或通过`API`去刷新`CDN`缓存，以确保用户能获取到最新版本。如果刷新不及时或配置错误，会导致用户看到旧版本，即“缓存污染”问题。

2. **安全性风险**
    * **攻击面扩大**：`CDN`的`URL`是公开的，如果你的资源链接被爬取或泄露，`CDN`会成为`DDoS`攻击的入口，虽然它能缓解一部分，但攻击流量依然会产生费用。
    * **敏感信息泄露**：如果将本应**私有的、带权限验证的**静态资源（如用户上传的合同、隐私图片）错误地放到了公共`CDN`上，可能会导致严重的数据泄露。**这类资源绝对不能放公共CDN。**

3. **成本问题**
    * **CDN流量费用**：虽然单价低，但总量巨大时，`CDN`费用也会非常可观。
    * **回源流量费用**：当`CDN`节点缓存未命中时，需要回源站拉取资源，这部分流量（回源流量）也是需要付费的。如果资源更新过于频繁或缓存配置不当，会导致大量回源，成本不降反升。

4. **潜在的稳定性问题**
    * **CDN服务商故障**：虽然概率极低，但一旦你的`CDN`服务商出现全局性故障，你的网站静态资源将全部无法加载。你需要有降级方案（例如，在检测到`CDN`失败时，动态地将资源`URL`切换回源站）。

### 最佳实践与总结

| 资源类型 | 推荐做法 | 原因 |
| :--- | :--- | :--- |
| **公共前端资源**<br>(`JS`, `CSS`, 字体, 公共图片) | **强烈推荐放CDN** | 用户受益最大，缓存效果好，能显著提升网站性能。 |
| **用户生成内容**<br>(`UGC`， 如用户头像、商品图) | **推荐放CDN** | 量大，访问分散，非常适合`CDN`分发。但需注意图片处理（缩略图等）。 |
| **大文件**<br>(`App`安装包、视频) | **必须放CDN** | 节省源站带宽，加速下载，是`CDN`的核心应用场景。 |
| **私密/敏感文件**<br>(付费内容、用户合同) | **不放公共CDN，或使用**<br>**带鉴权的私有CDN** | 安全第一。公共`CDN`无法保证隐私，必须通过源站或专门的私有资源服务进行权限校验。 |
| **频繁实时更新的小文件**<br>(如`JSON`配置， 实时行情图) | **谨慎使用CDN，或设置很短缓存** | 缓存反而会导致数据延迟。如果对实时性要求极高，可能直接回源更快。 |
| **开发/测试环境资源** | **通常不放CDN** | 避免不必要的成本，且需要频繁更新，缓存会带来调试困扰。 |

### 结论

<br/>

**采用“动静分离”的架构是基本原则。** 将公共的、不变的、量大的静态资源交给`CDN`，以提升性能和降低成本；而将动态的、私密的、实时性要求极高的资源保留在源站或通过专门的、安全的服务来处理。

不要走极端，**“全放”和“全不放”都是不合理的**。正确的做法是根据业务场景和资源特性，制定精细化的`CDN`使用策略。
