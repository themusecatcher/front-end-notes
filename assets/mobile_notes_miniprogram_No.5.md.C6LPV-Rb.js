import{_ as t,C as d,c,o as i,j as e,G as l,ab as n,a as r}from"./chunks/framework.B6eZocN-.js";const s="/front-end-notes/assets/6f1ce9685dbcb7a8.D2WytLL7.jpg",g="/front-end-notes/assets/6f1ce9685dbcb7a8.D2WytLL7.jpg",J=JSON.parse('{"title":"Taro3 & Vue3 & typescript & less","description":"","frontmatter":{},"headers":[],"relativePath":"mobile/notes/miniprogram/No.5.md","filePath":"mobile/notes/miniprogram/No.5.md","lastUpdated":1747113552000}'),h={name:"mobile/notes/miniprogram/No.5.md"};function p(u,o,b,m,S,f){const a=d("BackTop");return i(),c("div",null,[o[0]||(o[0]=e("h1",{id:"taro3-vue3-typescript-less",tabindex:"-1"},[e("code",null,"Taro3"),r(" & "),e("code",null,"Vue3"),r(" & "),e("code",null,"typescript"),r(" & "),e("code",null,"less"),r(),e("a",{class:"header-anchor",href:"#taro3-vue3-typescript-less","aria-label":'Permalink to "`Taro3` & `Vue3` & `typescript` & `less`"'},"​")],-1)),l(a),o[1]||(o[1]=n('<h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://taro.zone/" target="_blank" rel="noreferrer">Taro官网</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noreferrer">微信官方文档</a></li><li><a href="https://mp.weixin.qq.com/" target="_blank" rel="noreferrer">微信公众平台</a></li><li><a href="https://nutui.jd.com/taro/vue/4x/#/zh-CN/guide/start" target="_blank" rel="noreferrer">Nut UI</a></li></ul><h2 id="taro-中的-jsbridge" tabindex="-1"><code>Taro</code> 中的 <code>JSBridge</code> <a class="header-anchor" href="#taro-中的-jsbridge" aria-label="Permalink to &quot;`Taro` 中的 `JSBridge`&quot;">​</a></h2><ul><li><a href="https://docs.taro.zone/blog/2020-01-02-gmtc#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8E%A2%E7%B4%A2" target="_blank" rel="noreferrer">参考文档</a></li></ul><p>微信小程序主要分为 <strong>逻辑层</strong> 和 <strong>视图层</strong>，以及在他们之下的原生部分。逻辑层主要负责 <code>JS</code> 运行，视图层主要负责页面的渲染，它们之间主要通过 <code>Event</code> 和 <code>Data</code> 进行通信，同时通过 <code>JSBridge</code> 调用原生的 <code>API</code>。这也是以微信小程序为首的大多数小程序的架构。</p><br><p><img src="'+s+'" alt="alt text"></p><br><p>由于原生部分对于前端开发者来说就像是一个黑盒，因此，整个架构图的原生部分可以省略。同时，我们我们对 <strong>逻辑层</strong> 和 <strong>视图层</strong> 也做一下简化，最后可以得到小程序架构图的极简版：</p><br><p><img src="'+g+'" alt="alt text"></p><br><p>也就是说，只需要在逻辑层调用对应的 <code>App()</code>/<code>Page()</code> 方法，且在方法里面处理 <code>data</code>、提供生命周期/事件函数等，同时在视图层提供对应的模版及样式供渲染就能运行小程序了。这也是大多数小程序开发框架重点考虑和处理的部分。</p><p><code>Taro</code> 框架中的 <code>JSBridge</code> 是实现跨端开发的核心技术之一，它通过构建 <code>JavaScript</code> 与原生环境之间的通信通道，解决多端适配问题。以下从原理、实现机制、应用场景等方面详细解析：</p><h3 id="一、jsbridge-的核心作用" tabindex="-1">一、<code>JSBridge</code> 的核心作用 <a class="header-anchor" href="#一、jsbridge-的核心作用" aria-label="Permalink to &quot;一、`JSBridge` 的核心作用&quot;">​</a></h3><br><p><code>JSBridge</code> 是 <strong>JavaScript 与 Native 代码双向通信的桥梁</strong>，主要功能包括：</p><ol><li><strong>JavaScript 调用 Native</strong>：访问摄像头、地理位置、支付等原生功能。</li><li><strong>Native 调用 JavaScript</strong>：传递回调结果、推送消息或状态更新。</li><li><strong>跨端适配</strong>：统一不同平台（如微信、支付宝小程序）的 <code>API</code> 差异，实现代码复用。</li></ol><h3 id="二、taro-中-jsbridge-的实现原理" tabindex="-1">二、<code>Taro</code> 中 <code>JSBridge</code> 的实现原理 <a class="header-anchor" href="#二、taro-中-jsbridge-的实现原理" aria-label="Permalink to &quot;二、`Taro` 中 `JSBridge` 的实现原理&quot;">​</a></h3><h4 id="_1-基于-webview-和-jsbridge-的运行时架构" tabindex="-1">1. <strong>基于 WebView 和 JSBridge 的运行时架构</strong> <a class="header-anchor" href="#_1-基于-webview-和-jsbridge-的运行时架构" aria-label="Permalink to &quot;1. **基于 WebView 和 JSBridge 的运行时架构**&quot;">​</a></h4><ul><li><strong>WebView 渲染层</strong>：<code>Taro</code> 将 <code>React/Vue</code> 代码编译为标准 <code>Web</code> 代码，由 <code>WebView</code> 渲染页面。</li><li><strong>JSBridge 通信层</strong>：通过注入全局对象或拦截 <code>URL Scheme</code>，实现 <code>JavaScript</code> 与原生环境的交互。</li></ul><h4 id="_2-双向通信机制" tabindex="-1">2. <strong>双向通信机制</strong> <a class="header-anchor" href="#_2-双向通信机制" aria-label="Permalink to &quot;2. **双向通信机制**&quot;">​</a></h4><ul><li><strong>JavaScript → Native</strong>： <ul><li><strong>注入 API</strong>：通过 <code>WebView</code> 接口（如 <code>addJavascriptInterface</code>）向全局对象注入 <code>Native</code> 方法，前端直接调用（如 <code>Taro.navigateTo</code>）。</li><li><strong>拦截 URL Scheme</strong>：前端通过 <code>iframe.src</code> 发送自定义协议请求（如 <code>jsbridge://showToast</code>），<code>Native</code> 拦截并解析执行对应逻辑。</li></ul></li><li><strong>Native → JavaScript</strong>：直接执行拼接的 <code>JavaScript</code> 代码（如 <code>evaluateJavaScript</code>），要求目标方法挂载在全局 <code>window</code> 上。</li></ul><h4 id="_3-消息管理与回调处理" tabindex="-1">3. <strong>消息管理与回调处理</strong> <a class="header-anchor" href="#_3-消息管理与回调处理" aria-label="Permalink to &quot;3. **消息管理与回调处理**&quot;">​</a></h4><ul><li><strong>RPC 模型</strong>：将每次通信视为远程过程调用（<code>RPC</code>），前端发送请求时生成唯一 <code>ID</code>，<code>Native</code> 处理完成后通过 <code>ID</code> 匹配回调。</li><li><strong>JSONP 机制</strong>：通过全局回调函数处理异步结果，例如将回调函数暂存于 <code>window</code>，<code>Native</code> 执行后触发。</li></ul><h3 id="三、taro-中-jsbridge-的跨端适配策略" tabindex="-1">三、<code>Taro</code> 中 <code>JSBridge</code> 的跨端适配策略 <a class="header-anchor" href="#三、taro-中-jsbridge-的跨端适配策略" aria-label="Permalink to &quot;三、`Taro` 中 `JSBridge` 的跨端适配策略&quot;">​</a></h3><ol><li><p><strong>统一 API 设计</strong>：</p><ul><li><code>Taro</code> 封装了各平台小程序的原生 <code>API</code>（如 <code>wx.request</code>、<code>my.alert</code>），提供统一的调用接口（如 <code>Taro.request</code>）。</li><li>运行时根据当前平台动态切换底层实现。</li></ul></li><li><p><strong>组件与生命周期映射</strong>：</p><ul><li>将 <code>React/Vue</code> 生命周期（如 <code>componentDidMount</code>）映射到小程序生命周期（如 <code>onLoad</code>、<code>onShow</code>）。</li><li>通过 <code>JSBridge</code> 同步状态，例如页面显示/隐藏时触发 <code>componentDidShow</code> 或 <code>componentDidHide</code>。</li></ul></li><li><p><strong>多端差异化处理</strong>：</p><ul><li>针对不同平台的特性（如微信的 <code>openSetting</code>、支付宝的 <code>getAuthCode</code>），在 <code>JSBridge</code> 层做兼容性封装。</li><li>例如，调用 <code>Taro.getLocation</code> 时，<code>JSBridge</code> 自动适配微信的 <code>wx.getLocation</code> 或支付宝的 <code>my.getLocation</code>。</li></ul></li></ol><h3 id="四、jsbridge-在-taro-中的优势与局限性" tabindex="-1">四、<code>JSBridge</code> 在 <code>Taro</code> 中的优势与局限性 <a class="header-anchor" href="#四、jsbridge-在-taro-中的优势与局限性" aria-label="Permalink to &quot;四、`JSBridge` 在 `Taro` 中的优势与局限性&quot;">​</a></h3><h4 id="优势" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;**优势**：&quot;">​</a></h4><ul><li><strong>跨端适配性强</strong>：一套代码适配微信、支付宝、百度等小程序及 <code>H5</code>、<code>React Native</code>。</li><li><strong>开发效率高</strong>：避免重复编写多端逻辑，减少维护成本。</li><li><strong>性能优化</strong>：通过预编译和运行时优化，降低通信开销（如减少 <code>URL Scheme</code> 拦截频率）。</li></ul><h4 id="局限性" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;**局限性**：&quot;">​</a></h4><ul><li><strong>平台特性差异</strong>：部分原生功能（如微信小程序的订阅消息）需单独处理。</li><li><strong>通信性能瓶颈</strong>：频繁的 <code>JavaScript-Native</code> 调用可能影响流畅度，需合理设计通信频率。</li></ul><h3 id="五、实际应用案例" tabindex="-1">五、实际应用案例 <a class="header-anchor" href="#五、实际应用案例" aria-label="Permalink to &quot;五、实际应用案例&quot;">​</a></h3><ol><li><strong>饿了么小程序</strong>：通过 <code>Taro</code> 实现多端统一，<code>JSBridge</code> 处理订单、支付等原生功能调用。</li><li><strong>网易云音乐小程序</strong>：利用 <code>JSBridge</code> 同步播放状态，跨端保持一致的音频控制逻辑。</li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>Taro</code> 的 <code>JSBridge</code> 通过 <strong>WebView 渲染+原生通信</strong> 的架构，结合 <strong>API 注入、URL 拦截、RPC 回调</strong> 等机制，实现了高效的跨端开发。其核心价值在于屏蔽底层差异，让开发者专注于业务逻辑，同时通过运行时适配保障多端一致性。实际开发中需注意平台特性与性能优化，以充分发挥其优势。</p>',36))])}const v=t(h,[["render",p]]);export{J as __pageData,v as default};
