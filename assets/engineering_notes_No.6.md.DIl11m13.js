import{_ as i,c as e,o as a,ac as t}from"./chunks/framework.CphcMI6B.js";const k=JSON.parse('{"title":"Note 6","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/notes/No.6.md","filePath":"engineering/notes/No.6.md","lastUpdated":1760088464000}'),o={name:"engineering/notes/No.6.md"};function n(h,s,d,l,r,c){return a(),e("div",null,[...s[0]||(s[0]=[t('<h1 id="note-6" tabindex="-1">Note 6 <a class="header-anchor" href="#note-6" aria-label="Permalink to &quot;Note 6&quot;">​</a></h1><h2 id="vue-router-中-hash-和-history-模式的区别" tabindex="-1">Vue Router 中 <code>hash</code> 和 <code>history</code> 模式的区别 <a class="header-anchor" href="#vue-router-中-hash-和-history-模式的区别" aria-label="Permalink to &quot;Vue Router 中 `hash` 和 `history` 模式的区别&quot;">​</a></h2><h1 id="vue-router-中-hash-和-history-模式的区别-1" tabindex="-1">Vue Router 中 Hash 和 History 模式的区别 <a class="header-anchor" href="#vue-router-中-hash-和-history-模式的区别-1" aria-label="Permalink to &quot;Vue Router 中 Hash 和 History 模式的区别&quot;">​</a></h1><p>在 <code>Vue Router</code> 中，有两种路由模式：<strong>hash</strong> 和 <strong>history</strong>。它们有不同的工作原理、优缺点和适用场景。</p><h2 id="核心区别" tabindex="-1">核心区别 <a class="header-anchor" href="#核心区别" aria-label="Permalink to &quot;核心区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th><code>Hash</code> 模式</th><th><code>History</code> 模式</th></tr></thead><tbody><tr><td><code>URL</code> 格式</td><td><code>http://example.com/#/path</code></td><td><code>http://example.com/path</code></td></tr><tr><td>服务器配置</td><td>不需要特殊配置</td><td>需要配置支持</td></tr><tr><td><code>SEO</code> 友好性</td><td>较差</td><td>较好</td></tr><tr><td>兼容性</td><td>所有浏览器</td><td>需要 <code>HTML5 History API</code> 支持</td></tr><tr><td>实现原理</td><td>使用 <code>URL hash</code> 部分</td><td>使用 <code>History API</code></td></tr></tbody></table><h2 id="详细解析" tabindex="-1">详细解析 <a class="header-anchor" href="#详细解析" aria-label="Permalink to &quot;详细解析&quot;">​</a></h2><h3 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式&quot;">​</a></h3><ul><li>使用 <code>URL</code> 的 <code>hash</code>（<code>#</code>）部分来模拟路由</li><li>当 <code>hash</code> 改变时，浏览器不会向服务器发送请求</li><li>完全在客户端处理路由</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式&quot;">​</a></h3><ul><li>使用 <code>HTML5 History API</code> 实现</li><li><code>URL</code> 看起来更自然，没有 <code>#</code> 符号</li><li>需要服务器端配置支持，否则刷新页面会出现 <code>404</code></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><ol><li><p><strong>使用 Hash 模式的情况</strong>：</p><ul><li>不需要 <code>SEO</code> 支持</li><li>没有服务器配置权限</li><li>需要兼容旧版浏览器</li></ul></li><li><p><strong>使用 History 模式的情况</strong>：</p><ul><li>需要 <code>SEO</code> 友好的 <code>URL</code></li><li>有服务器配置权限</li><li>目标用户使用现代浏览器</li></ul></li></ol><h2 id="服务器配置示例" tabindex="-1">服务器配置示例 <a class="header-anchor" href="#服务器配置示例" aria-label="Permalink to &quot;服务器配置示例&quot;">​</a></h2><p>对于 <code>History</code> 模式，服务器需要配置以支持直接访问路由：</p><h3 id="nginx-配置" tabindex="-1">Nginx 配置 <a class="header-anchor" href="#nginx-配置" aria-label="Permalink to &quot;Nginx 配置&quot;">​</a></h3><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> / </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try_files </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$uri $uri/ /index.html;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="node-js-express-配置" tabindex="-1">Node.js (Express) 配置 <a class="header-anchor" href="#node-js-express-配置" aria-label="Permalink to &quot;Node.js (Express) 配置&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;connect-history-api-fallback&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">history</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h2 id="单点登录-sso-single-sign-on" tabindex="-1">单点登录 <code>SSO</code>(Single Sign-On) <a class="header-anchor" href="#单点登录-sso-single-sign-on" aria-label="Permalink to &quot;单点登录 `SSO`(Single Sign-On)&quot;">​</a></h2><h3 id="_1-session-cookie-模式" tabindex="-1">1. <code>session</code> + <code>cookie</code> 模式 <a class="header-anchor" href="#_1-session-cookie-模式" aria-label="Permalink to &quot;1. `session` + `cookie` 模式&quot;">​</a></h3><p>用户登录时，子系统会将用户引导到认证中心去登录，账号密码验证通过后，建立（已有）一个 <code>session</code> 表格，一个键值对，<code>key</code> 对应生成的唯一 <code>sessionID</code>，<code>value</code> 是他对应的身份信息，每个键值对有一个过期时间，到期自动清除，该表格通常存储到 <code>redis</code> 数据库，同时将 <code>sessionID</code> 下发给用户，用户进行保存，登录完成。 当用户携带 <code>sessionID</code> 登录子系统时，子系统会请求认证中心去进行验证，认证中心去查询是否存在对应的键值对，有就返回用户信息给子系统，没有就是未登录或登录已过期</p><ul><li>优点：有强控制力，比如：某天需要让某个用户或者某一批用户下线，只需要删除这些用户在表格中对应的键值对即可</li><li>缺点：所有的子系统每次请求都需要发起认证请求，每天需要接送非常大量的请求，需要做服务器集群，扩容，总体成本高，另外如果子系统扩容，认证中心也需要跟着扩容，成本高（大公司无所谓成本只在乎强控制力，中小型公司更在乎成本，牺牲强控制力）</li></ul><h3 id="_2-token-模式-分布式的认证模式" tabindex="-1">2. <code>token</code> 模式（分布式的认证模式） <a class="header-anchor" href="#_2-token-模式-分布式的认证模式" aria-label="Permalink to &quot;2. `token` 模式（分布式的认证模式）&quot;">​</a></h3><p>没有服务器键值对表格，首先到认证中心登录，认证中心验证没问题后不会保存任何信息，只会生成一个不可被篡改的 <code>token</code>，格式一般来说是 <code>JWT</code>（无法被篡改），然后认证中心会将 <code>token</code> 发送给用户，用户自行保存，然后当用户访问子系统时，用户携带该 <code>token</code>，子系统独立验证该 <code>token</code>，（验证方式比如，子系统与认证中心交换一个密钥，通过这个密钥自行去验证用户 <code>token</code>）。 此时，如果子系统需要扩容，则认证系统无需扩容，所以会说 <code>token</code> 模式是一种分布式的认证模式，即子系统自行认证。认证中心只管颁发，子系统只管认证，认证中心压力小</p><ul><li>优点：成本低</li><li>缺点：认证中心对用户的控制力弱，无法让用户立即下线，因为 <code>token</code> 还被用户保存着。</li></ul><h3 id="_3-双-token-模式" tabindex="-1">3. 双 token 模式 <a class="header-anchor" href="#_3-双-token-模式" aria-label="Permalink to &quot;3. 双 token 模式&quot;">​</a></h3><p><code>token</code> 模式未解决这种对用户控制力弱的问题，于是考虑采用折中的双 <code>token</code> 模式，用户去认证中心登录认证，认证成功后，认证中心返回两个 <code>token</code>，一个过期时间短的请求 <code>token</code>（<code>10min</code> 或 <code>20min</code> 等），一个过期时间长的刷新 <code>token</code>，当用户访问子系统时，只需携带过期时间短的 <code>token</code>，而子系统只需去验证请求 <code>token</code> 即可，当该 <code>token</code> 过期后，用户只需携带刷新 <code>token</code> 去认证中心换取请求 <code>token</code>（即每隔一段时间需要来认证中心认证一次，方便认证中心的控制）</p>',30)])])}const g=i(o,[["render",n]]);export{k as __pageData,g as default};
