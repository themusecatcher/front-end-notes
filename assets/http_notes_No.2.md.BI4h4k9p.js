import{_ as c,C as t,c as r,o as l,j as e,G as a,ac as n,a as s}from"./chunks/framework.CtEZafqV.js";const u=JSON.parse('{"title":"Note 2","description":"","frontmatter":{},"headers":[],"relativePath":"http/notes/No.2.md","filePath":"http/notes/No.2.md","lastUpdated":1762760523000}'),i={name:"http/notes/No.2.md"};function g(p,o,N,h,C,D){const d=t("BackTop");return l(),r("div",null,[o[0]||(o[0]=e("h1",{id:"note-2",tabindex:"-1"},[s("Note 2 "),e("a",{class:"header-anchor",href:"#note-2","aria-label":'Permalink to "Note 2"'},"​")],-1)),a(d),o[1]||(o[1]=n(`<h2 id="cdn-内容分发网络-工作原理详解" tabindex="-1">CDN（内容分发网络）工作原理详解 <a class="header-anchor" href="#cdn-内容分发网络-工作原理详解" aria-label="Permalink to &quot;CDN（内容分发网络）工作原理详解&quot;">​</a></h2><p><code>CDN</code>（内容分发网络）指的是<strong>一组分布在各个地区的服务器</strong>。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。<code>CDN</code> 可以提供快速服务，较少受高流量影响。</p><p><code>CDN</code> 被广泛用于传输样式表和 <code>JavaScript</code> 文件（例如 Bootstrap、jQuery 库等）的静态资源。对这些库文件使用 <code>CDN</code> 技术，有以下几点好处：</p><ul><li>通过 <code>CDN</code> 向用户分发传输相关库的静态资源文件，可以降低我们自身服务器的请求压力。</li><li>大多数 <code>CDN</code> 在全球都有服务器，所以 <code>CDN</code> 上的服务器在地理位置上可能比你自己的服务器更接近你的用户。地理距离会按比例影响延迟。</li><li><code>CDN</code> 已经配置了恰当的缓存设置。使用 <code>CDN</code> 节省了在你的服务器中对静态资源文件的配置。</li></ul><p><code>CDN</code>（内容分发网络，Content Delivery Network）是一种通过<strong>分布式节点技术</strong>优化内容传输的网络架构，其核心原理是<strong>将网站或应用的资源（如静态文件、视频、动态内容等）缓存至全球各地的边缘服务器，使用户能够从距离最近的节点快速获取数据，从而减少延迟、提升访问速度并降低源服务器负载</strong>。以下是 <code>CDN</code> 工作原理的详细解析：</p><h3 id="一、cdn的核心原理" tabindex="-1"><strong>一、CDN的核心原理</strong> <a class="header-anchor" href="#一、cdn的核心原理" aria-label="Permalink to &quot;**一、CDN的核心原理**&quot;">​</a></h3><ol><li><p><strong>分布式缓存与就近访问</strong><br><code>CDN</code> 通过在全球部署边缘服务器（节点），将源站内容缓存到离用户最近的节点上。当用户请求资源时，<code>CDN</code> 通过智能 <code>DNS</code> 解析或 <code>HTTP</code> 重定向技术，将用户引导至最优节点。若节点已缓存所需内容，则直接返回；若未缓存，则从源站拉取内容并缓存至节点，供后续用户使用。</p></li><li><p><strong>DNS智能解析与路由选择</strong></p></li></ol><ul><li>用户发起请求时，<code>DNS</code> 系统通过 <code>CNAME</code> 记录将域名解析权交给 <code>CDN</code> 的智能 <code>DNS</code> 服务器。</li><li><code>CDN</code> 的智能 <code>DNS</code> 服务器根据用户 <code>IP</code> 地址、地理位置、网络状况及节点负载情况，选择最优边缘节点 <code>IP</code> 返回给用户，实现智能路由。</li></ul><ol start="3"><li><p><strong>负载均衡与冗余机制</strong><br><code>CDN</code> 通过全局负载均衡（GSLB）和区域负载均衡（SLB）动态分配流量，避免单一节点过载。当某节点故障时，请求会自动切换至其他可用节点，确保服务连续性。</p></li><li><p><strong>动态内容加速</strong><br> 针对动态内容（如实时数据、交互式页面），<code>CDN</code> 采用<strong>动态加速技术</strong>，如 <code>TCP</code> 链路优化、<code>BGP</code> 路由优化等，缩短用户与源站之间的传输路径，降低延迟。</p></li></ol><h3 id="二、cdn的关键技术" tabindex="-1"><strong>二、CDN的关键技术</strong> <a class="header-anchor" href="#二、cdn的关键技术" aria-label="Permalink to &quot;**二、CDN的关键技术**&quot;">​</a></h3><ol><li><p><strong>缓存机制</strong></p><p>静态资源（图片、CSS、JS等）被缓存在边缘节点，通过 <code>TTL</code>（生存时间）控制缓存更新频率。首次请求需回源，后续请求直接从缓存响应，显著减少源站压力。</p><div class="tip custom-block"><p class="custom-block-title">备注</p><p><code>TTL</code>（Time to Live）缓存时间是指<strong>数据在缓存中存储的有效时长，用于控制缓存数据的过期和更新机制</strong>。</p></div></li><li><p><strong>内容预取与预热</strong><br><code>CDN</code> 支持预取策略，主动将热门内容提前分发至节点，或在源站更新后主动刷新缓存，避免用户访问时因回源造成延迟。</p></li><li><p><strong>安全防护</strong><br><code>CDN</code> 集成 <code>DDoS</code> 防护、Web应用防火墙（WAF）、HTTPS 加密等安全功能，通过流量清洗和恶意请求过滤保护源站安全。</p></li><li><p><strong>数据传输优化</strong><br> 采用压缩（如Gzip）、分块传输、HTTP/2 协议优化等技术，减少传输数据量，提升加载速度。</p></li></ol><h3 id="三、cdn的典型工作流程" tabindex="-1"><strong>三、CDN的典型工作流程</strong> <a class="header-anchor" href="#三、cdn的典型工作流程" aria-label="Permalink to &quot;**三、CDN的典型工作流程**&quot;">​</a></h3><ol><li><strong>用户请求</strong>：用户访问网站域名，发起资源请求。</li><li><strong>DNS解析</strong>：本地 <code>DNS</code> 通过配置 <code>CNAME</code> 将请求转发至 <code>CDN</code> 的智能 <code>DNS</code> 服务器，获取最优节点 <code>IP</code>。</li><li><strong>节点响应</strong>：用户连接至边缘节点，若资源已缓存则直接返回；否则节点回源拉取数据并缓存。</li><li><strong>内容交付</strong>：用户从边缘节点快速获取内容，完成访问。</li></ol><h3 id="四、cdn的优势" tabindex="-1"><strong>四、CDN的优势</strong> <a class="header-anchor" href="#四、cdn的优势" aria-label="Permalink to &quot;**四、CDN的优势**&quot;">​</a></h3><ul><li><strong>加速访问</strong>：减少跨地域、跨运营商传输延迟，提升页面加载速度。</li><li><strong>降低负载</strong>：分担源站流量，避免服务器过载。</li><li><strong>高可用性</strong>：冗余节点和故障切换机制保障服务稳定性。</li><li><strong>成本优化</strong>：减少带宽消耗，降低服务器运维成本。</li><li><strong>安全增强</strong>：抵御 <code>DDoS</code> 攻击，提升数据安全性。</li></ul><h3 id="五、适用场景" tabindex="-1"><strong>五、适用场景</strong> <a class="header-anchor" href="#五、适用场景" aria-label="Permalink to &quot;**五、适用场景**&quot;">​</a></h3><ul><li><strong>静态资源加速</strong>：如图片、视频、文档等。</li><li><strong>动态内容优化</strong>：如 <code>API</code> 接口、实时交互页面。</li><li><strong>大文件下载与流媒体</strong>：如软件包、直播/点播视频。</li><li><strong>全球化业务</strong>：覆盖多地区用户，解决跨国访问延迟问题。</li></ul><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><p><code>CDN</code> 通过分布式缓存、智能路由、负载均衡等核心技术，构建了高效、稳定、安全的内容分发网络。其核心目标是通过<strong>缩短用户与资源的物理距离</strong>和<strong>优化传输路径</strong>，实现快速响应与高可用性，已成为现代互联网基础设施的重要组成部分。对于需要提升用户体验、应对高并发场景的企业，<code>CDN</code> 是必不可少的解决方案。</p><h2 id="cname-canonical-name-规范名称" tabindex="-1"><code>CNAME</code>（Canonical Name，规范名称） <a class="header-anchor" href="#cname-canonical-name-规范名称" aria-label="Permalink to &quot;\`CNAME\`（Canonical Name，规范名称）&quot;">​</a></h2><p>在 <code>DNS</code>（域名系统） 中，<code>CNAME</code> 是一种别名记录，用于<strong>将一个域名指向另一个域名（而非直接指向 <code>IP</code> 地址）</strong>。在 <code>CDN</code> 的 <code>DNS</code> 解析流程中，<code>CNAME</code> 记录起到路由控制的关键作用，<strong>帮助实现用户请求的智能分发</strong>。以下是其核心机制和流程：</p><h3 id="_1-cname-的核心作用" tabindex="-1"><strong>1. CNAME 的核心作用</strong> <a class="header-anchor" href="#_1-cname-的核心作用" aria-label="Permalink to &quot;**1. CNAME 的核心作用**&quot;">​</a></h3><ul><li><strong>别名映射</strong>：<code>CNAME</code> 记录允许将一个域名（如 <code>cdn.example.com</code>）设置为另一个域名（如 <code>example.cdnprovider.com</code>）的别名。</li><li><strong>解析权转移</strong>：通过 <code>CNAME</code>，域名解析权从原始 <code>DNS</code> 服务器转移到 <code>CDN</code> 提供商的 <code>DNS</code> 系统，使 <code>CDN</code> 能够动态选择最优节点。</li></ul><h3 id="_2-在-cdn-中的应用场景" tabindex="-1"><strong>2. 在 CDN 中的应用场景</strong> <a class="header-anchor" href="#_2-在-cdn-中的应用场景" aria-label="Permalink to &quot;**2. 在 CDN 中的应用场景**&quot;">​</a></h3><br><p>当用户访问使用 <code>CDN</code> 加速的网站（如 <code>www.example.com</code>）时，<code>CDN</code> 的工作流程如下：</p><ol><li><p><strong>用户发起请求</strong> 用户输入 <code>www.example.com</code>，向本地 <code>DNS</code> 服务器发起解析请求。</p></li><li><p><strong>触发 CNAME 解析</strong></p></li></ol><ul><li>原域名 <code>www.example.com</code> 的 <code>DNS</code> 记录中配置了 <code>CNAME</code>，指向 <code>CDN</code> 服务商提供的域名（如 <code>example.cdnprovider.net</code>）。</li><li>本地 <code>DNS</code> 服务器发现 <code>CNAME</code> 记录后，转而向 <code>CDN</code> 服务商的 <code>DNS</code> 系统发起解析请求。</li></ul><ol start="3"><li><strong>CDN 智能 DNS 决策</strong></li></ol><p><code>CDN</code> 的 <strong>智能 DNS 服务器</strong> 根据以下因素选择最优边缘节点：</p><ul><li>用户的地理位置（通过 <code>IP</code> 定位）</li><li>网络运营商（如电信、联通）</li><li>边缘节点的实时负载和健康状况</li></ul><ol start="4"><li><strong>返回最优节点 IP</strong></li></ol><p><code>CDN</code> 的 <code>DNS</code> 服务器将最优节点的 <code>IP</code> 地址（如 <code>1.2.3.4</code>）返回给用户，用户直接访问该边缘节点获取内容。</p><h3 id="_3-配置示例" tabindex="-1"><strong>3. 配置示例</strong> <a class="header-anchor" href="#_3-配置示例" aria-label="Permalink to &quot;**3. 配置示例**&quot;">​</a></h3><br><p>假设你的网站 <code>www.example.com</code> 使用某 <code>CDN</code> 服务，配置步骤如下：</p><ol><li><strong>在 CDN 服务商处添加域名</strong></li></ol><p>将 <code>www.example.com</code> 添加到 <code>CDN</code> 控制台，<code>CDN</code> 会生成一个专属 <code>CNAME</code> 域名（如 <code>example-1234.cdnprovider.com</code>）。</p><ol start="2"><li><strong>在 DNS 服务商处设置 CNAME 记录</strong></li></ol><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>记录类型: CNAME  </span></span>
<span class="line"><span>主机记录: www  </span></span>
<span class="line"><span>记录值: example-1234.cdnprovider.com  </span></span>
<span class="line"><span>TTL: 600（秒）</span></span></code></pre></div><p>此配置将 <code>www.example.com</code> 的解析权交给 <code>CDN</code> 服务商。</p><h3 id="_4-cname-的优势与注意事项" tabindex="-1"><strong>4. CNAME 的优势与注意事项</strong> <a class="header-anchor" href="#_4-cname-的优势与注意事项" aria-label="Permalink to &quot;**4. CNAME 的优势与注意事项**&quot;">​</a></h3><h4 id="优势" tabindex="-1"><strong>优势</strong> <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;**优势**&quot;">​</a></h4><ul><li><strong>灵活性</strong>：<code>CDN</code> 服务商可动态调整节点分配策略，无需用户手动修改 <code>DNS</code> 记录。</li><li><strong>集中管理</strong>：通过 <code>CNAME</code> 解耦域名与 <code>IP</code>，<code>CDN</code> 服务商可统一优化节点网络。</li><li><strong>无缝切换</strong>：当 <code>CDN</code> 节点故障时，<code>DNS</code> 可快速切换至备用节点，用户无感知。</li></ul><h4 id="注意事项" tabindex="-1"><strong>注意事项</strong> <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;**注意事项**&quot;">​</a></h4><ul><li><strong>TTL 依赖</strong>：<code>DNS</code> 记录的 <code>TTL</code>（缓存时间）会影响 <code>CNAME</code> 更新的生效速度。</li><li><strong>解析延迟</strong>：多级 <code>DNS</code> 查询（本地 <code>DNS</code> → <code>CDN DNS</code>）可能略微增加解析时间。</li><li><strong>CNAME 限制</strong>：一个域名只能有一条 <code>CNAME</code> 记录，且不能与其他记录（如 <code>MX</code>、<code>TXT</code>）共存。</li></ul><h3 id="_5-其他相关-dns-记录" tabindex="-1"><strong>5. 其他相关 DNS 记录</strong> <a class="header-anchor" href="#_5-其他相关-dns-记录" aria-label="Permalink to &quot;**5. 其他相关 DNS 记录**&quot;">​</a></h3><ul><li><strong>A 记录</strong>：直接映射域名到 <code>IP</code>，适用于固定 <code>IP</code> 的场景（无 <code>CDN</code>）。</li><li><strong>AAAA 记录</strong>：类似 <code>A</code> 记录，但指向 <code>IPv6</code> 地址。</li><li><strong>NS 记录</strong>：指定域名由哪台 <code>DNS</code> 服务器解析（通常用于域名托管）。</li></ul><h3 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><p>在 <code>CDN</code> 中，<code>CNAME</code> 记录是<strong>连接用户与 CDN 网络的核心桥梁</strong>。通过<strong>将域名解析权转移至 <code>CDN</code> 服务商的智能 <code>DNS</code> 系统，结合地理位置、网络状态等实时数据，最终实现用户请求的最优分发，显著提升访问速度和稳定性</strong>。</p><hr><h2 id="全局负载均衡-gslb-与区域负载均衡-slb" tabindex="-1"><strong>全局负载均衡（GSLB）与区域负载均衡（SLB）</strong> <a class="header-anchor" href="#全局负载均衡-gslb-与区域负载均衡-slb" aria-label="Permalink to &quot;**全局负载均衡（GSLB）与区域负载均衡（SLB）**&quot;">​</a></h2><p>全局负载均衡（<code>GSLB</code>，Global Server Load Balancing）和区域负载均衡（<code>SLB</code>，Server Load Balancing）是分层流量管理的核心技术，分别解决<strong>广域网</strong>和<strong>局域网</strong>范围内的资源分配问题。</p><h3 id="核心区别" tabindex="-1"><strong>核心区别</strong> <a class="header-anchor" href="#核心区别" aria-label="Permalink to &quot;**核心区别**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>全局负载均衡（GSLB）</strong></th><th><strong>区域负载均衡（SLB）</strong></th></tr></thead><tbody><tr><td><strong>作用范围</strong></td><td>跨地域、跨数据中心（广域网）</td><td>同一数据中心或区域内部（局域网）</td></tr><tr><td><strong>决策依据</strong></td><td>地理位置、网络延迟、节点健康状态、运营商</td><td>服务器负载、连接数、CPU/内存利用率</td></tr><tr><td><strong>技术实现</strong></td><td>基于 <code>DNS</code> 或 <code>Anycast</code> 路由的智能调度</td><td>基于硬件/软件（如 F5、Nginx、HAProxy）</td></tr><tr><td><strong>目标</strong></td><td>优化用户访问路径，选择最优数据中心</td><td>优化服务器资源利用率，避免单点过载</td></tr></tbody></table><h2 id="浏览器从输入url都发生了什么" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">浏览器从输入url都发生了什么？</a> <a class="header-anchor" href="#浏览器从输入url都发生了什么" aria-label="Permalink to &quot;[浏览器从输入url都发生了什么？](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)&quot;">​</a></h2><blockquote><p>简单总结：HTML 解析 -&gt; 样式计算 -&gt; 布局 -&gt; 分层 -&gt; 绘制 -&gt; 分块 -&gt; 光栅化 -&gt; 显示</p></blockquote><ol><li>根据网址进行 <code>DNS</code> 解析，如果配置了 <code>CNAME</code>，<code>DNS</code> 系统通过 <code>CNAME</code> 记录将域名解析权交给 <code>CDN</code> 的智能 <code>DNS</code> 服务器。<code>CDN</code> 的智能 <code>DNS</code> 服务器根据用户 <code>IP</code> 地址、地理位置、网络状况及节点负载情况，选择最优边缘节点 <code>IP</code> 返回。</li><li>客户端根据 <code>IP</code> 地址找到对应的服务器，通过 <code>TCP</code> 三次握手，与服务器建立连接</li><li>客户端发起 <code>HTTP</code> 请求，请求对应资源，这个请求通常是一个 <code>html</code> 文件</li><li>服务器响应并返回相应数据，<code>HTTP</code> 报文（如：HTML文件）</li><li>解析 <code>HTML</code>：浏览器通过网络接收数据，解析 <code>HTML</code> 并构造 <code>DOM树</code></li><li>解析 <code>CSS</code>：主线程解析到 <code>&lt;link&gt;</code> 位置，此时外部的 <code>CSS</code> 文件还没有下载解析好，主线程不会等待，继续解析后续的 <code>HTML</code>。这是因为下载和解析 <code>CSS</code> 的工作是在预解析线程中进行的。这就是 <code>CSS</code> 不会阻塞 <code>HTML</code> 解析的根本原因。这一步会解析 <code>CSS</code> 并构建 <code>CSSOM树</code>（CSS对象模型树）。</li><li>主线程解析到 <code>&lt;script&gt;</code> 位置时，会停止解析 <code>HTML</code>，转而等待 <code>JS</code> 文件下载，并将全局代码解析执行完成后，才会继续解析 <code>HTML</code>。这是因为 <code>JS</code> 代码的执行过程可能会修改当前的 <code>DOM</code> 树，所以 <code>DOM</code> 树的生成必须暂停。这就是 <code>JS</code> 会阻塞 <code>HTML</code> 解析的根本原因。</li></ol><p>解析完成后，会得到 <code>DOM</code> 树和 <code>CSSOM</code> 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 <code>CSSOM</code> 树中。</p><ol start="8"><li><p>样式计算：主线程会遍历得到的 <code>DOM</code> 树，依次为树中的每个节点计算出它最终的样式，称之为 <code>Computed Style</code>。在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如 <code>em</code> 会变成 <code>px</code></p></li><li><p>将解析创建的 <code>DOM树</code> 和 <code>CSSOM树</code> 合成一个渲染树（<code>Rendering Tree</code>），也称为布局树，所谓的回流即重新生成布局树（例如<code>clientWidth、offsetWidth、scrollWidth</code>等会导致强制回流，但这些属性拿到的尺寸和位置是不包括元素变形的情况如 <code>transform</code>，变形的尺寸和位置需要使用 <code>getBoundingClientRect()</code>）</p></li><li><p>根据渲染树计算每个可见元素的布局（即尺寸和位置），然后将其绘制到屏幕上（在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 <code>GPU</code> 而不是 <code>CPU</code> 上绘制屏幕的一部分来提高性能，从而释放主线程。） 布局是确定渲染树中所有节点的尺寸和位置，以及确定页面上每个对象的大小和位置的过程。</p></li><li><p>分层：主线程使用一套复杂的策略对整个布局树进行分层。浏览器中的 <code>Layers</code> 可以查看每个页面的分层效果。</p></li><li><p>绘制：在每个层进行绘制过程，主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。<strong>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成</strong>。</p><p>合成线程会对每个图层进行分块，将其划分为更多的小区域；分块完成后，进入光栅化阶段，合成线程会将块信息交给 <code>GPU</code> 进程，以极高的速度完成光栅化。<code>GPU</code> 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p></li><li><p>合成：在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p></li><li><p>显示在用户浏览器页面</p></li><li><p>最后，客户端与服务器进行 <code>TCP</code> 四次挥手断开连接，也可能复用连接</p></li></ol><p>不会被显示的元素，如 <code>&lt;head&gt;</code> 元素及其子元素，以及任何带有 <code>display: none</code> 的节点，如用户代理样式表中的 script <code>{ display: none; }</code>，都不会包含在渲染树中，因为它们不会出现在渲染输出中。应用了 <code>visibility: hidden</code> 的节点会包含在渲染树中，因为它们会占用空间。</p><h3 id="关键渲染路径" tabindex="-1">关键渲染路径 <a class="header-anchor" href="#关键渲染路径" aria-label="Permalink to &quot;关键渲染路径&quot;">​</a></h3><br><p>关键渲染路径是<strong>浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列</strong>。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 <code>文档对象模型(DOM)</code>，<code>CSS 对象模型 (CSSOM)</code>，<code>渲染树</code>和<code>布局</code>。</p><p><code>Web</code> 性能包含了服务器请求和响应、加载、执行脚本、渲染、布局和绘制每个像素到屏幕上。</p><p>网页请求从 <code>HTML</code> 文件请求开始。服务器返回 <code>HTML</code> ——响应头和数据。然后浏览器开始解析 <code>HTML</code>，转换收到的数据为 <code>DOM</code> 树。浏览器每次发现外部资源就初始化请求，无论是样式、脚本或者嵌入的图片引用。有时请求会阻塞，这意味着解析剩下的 <code>HTML</code> 会被终止直到重要的资源被处理。浏览器接着解析 <code>HTML</code>，发请求和构造 <code>DOM</code> 直到文件结尾，这时开始构造 <code>CSS</code> 对象模型。等到 <code>DOM</code> 和 <code>CSSOM</code> 完成之后，浏览器构造渲染树，计算所有可见内容的样式。一旦渲染树完成布局开始，定义所有渲染树元素的位置和大小。完成之后，页面被渲染完成，或者说是绘制到屏幕上。</p><p>用户看到页面分为两个阶段：</p><ul><li>页面内容加载完成。对应 <code>DOMContentLoaded</code></li><li>页面资源完成。对应 <code>Load</code></li></ul><p>整个关键渲染路径包括以下几个步骤：</p><ol><li>解析 <code>HTML</code>，生成 <code>DOM</code> 树（DOM）</li><li>解析 <code>CSS</code>，生成 <code>CSSOM</code> 树（CSSOM）</li><li>将 <code>DOM</code> 树和 <code>CSSOM</code> 树 合成渲染树（Rendering Tree）</li><li>根据渲染树，计算每个可见元素的布局（Layout）</li><li>将各个元素绘制到屏幕上（Paint）</li></ol>`,70))])}const b=c(i,[["render",g]]);export{u as __pageData,b as default};
