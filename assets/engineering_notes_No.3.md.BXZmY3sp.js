import{_ as i,c as a,o as t,ac as n}from"./chunks/framework.CphcMI6B.js";const g=JSON.parse('{"title":"Note 3","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/notes/No.3.md","filePath":"engineering/notes/No.3.md","lastUpdated":1761186997000}'),l={name:"engineering/notes/No.3.md"};function e(h,s,p,k,d,o){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="note-3" tabindex="-1">Note 3 <a class="header-anchor" href="#note-3" aria-label="Permalink to &quot;Note 3&quot;">​</a></h1><h2 id="如何清理源码里面没有被应用的代码-主要是-js、ts、css-代码" tabindex="-1">如何清理源码里面没有被应用的代码，主要是 JS、TS、CSS 代码 <a class="header-anchor" href="#如何清理源码里面没有被应用的代码-主要是-js、ts、css-代码" aria-label="Permalink to &quot;如何清理源码里面没有被应用的代码，主要是 JS、TS、CSS 代码&quot;">​</a></h2><h3 id="针对-js、ts-代码" tabindex="-1">针对 <code>JS</code>、<code>TS</code> 代码 <a class="header-anchor" href="#针对-js、ts-代码" aria-label="Permalink to &quot;针对 \`JS\`、\`TS\` 代码&quot;">​</a></h3><ol><li>使用 <code>ESlint</code></li></ol><ul><li><a href="https://eslint.nodejs.cn/" target="_blank" rel="noreferrer">ESlint</a>（在源码中进行检测并提示）、<a href="https://terser.org/" target="_blank" rel="noreferrer">Terser</a>（打包后自动完成一些裁剪）：读取源码文件 -&gt; 生成抽象语法树（<code>AST</code>） -&gt; 分析 -&gt; ...<br>都只能针对 <code>JS</code> 文件不支持 <code>CSS</code> 且只能是单模块（单文件），例如一个模块导出，但另一个模块未使用，这种情况无法处理。</li></ul><p>比如：在 <code>.eslintrc</code> 配置文件中 <code>rules</code> 配置 <code>no-unused-vars</code> 规则，在编辑器中会提示未使用的变量和函数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;no-unused-vars&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;warn&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>使用 <code>TypeScript</code> 编译器选项</li></ol><ul><li>对于 TypeScript 项目，可以在 <code>tsconfig.json</code> 文件中启用 <code>&quot;noUnusedLocals&quot;: true</code> 和 <code>&quot;noUnusedParameters&quot;</code> 选项，以识别未使用的本地变量和函数参数。</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;noUnusedLocals&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;noUnusedParameters&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>利用 <code>Webpack</code> 或 <code>Rollup</code> 的 <code>Tree Shaking</code> 功能</li></ol><ul><li>打包构建工具（如 <code>Webpack</code>、<code>Rollup</code>）的树摇优化（<code>Tree Shaking</code>）功能：读取源码文件 -&gt; 分析模块依赖关系 -&gt; 生成新的 <code>AST</code> 并进行优化 -&gt; 生成新的代码 -&gt; ...<br>也只能支持 <code>JS</code> 或 <code>TS</code>（编译后也是 <code>JS</code>）不支持 <code>CSS</code>，且必须是 <code>ESM</code> 的模块化标准（不支持 <code>CommonJS</code>），支持多模块（多文件），例如一个模块导出，单另一个模块未使用，这种情况也可以处理。 不支持动态导入，比如：<code>require()（虽然是同步加载，但可以动态调用，如条件语句）</code> 或 <code>ESM</code> 的 <code>import()</code> 方式。因为它是静态分析，即只能在编译时态进行静态分析。</li></ul><h3 id="针对-css-代码" tabindex="-1">针对 <code>CSS</code> 代码 <a class="header-anchor" href="#针对-css-代码" aria-label="Permalink to &quot;针对 \`CSS\` 代码&quot;">​</a></h3><ol><li>使用 <a href="https://purgecss.com/" target="_blank" rel="noreferrer">PurgeCSS</a></li></ol><ul><li><code>PurgeCSS</code> 会对整个工程代码进行分析，去除未使用的选择器。非常适合清除未应用的 <code>CSS</code> 代码。</li><li>使用 <code>PurgeCSS</code> 时，配置文件路径、忽略的文件或选择器等，它会分析这些文件来确定哪些 <code>CSS</code> 选择器是被使用的。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PurgeCSSPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  paths: glob.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PATHS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">src</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/**/*\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { nodir: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="commonjs-和-esm-模块系统" tabindex="-1"><code>CommonJS</code> 和 <code>ESM</code> 模块系统 <a class="header-anchor" href="#commonjs-和-esm-模块系统" aria-label="Permalink to &quot;\`CommonJS\` 和 \`ESM\` 模块系统&quot;">​</a></h2><h3 id="一、核心差异总览" tabindex="-1"><strong>一、核心差异总览</strong> <a class="header-anchor" href="#一、核心差异总览" aria-label="Permalink to &quot;**一、核心差异总览**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>CommonJS</th><th>ESM (ES Modules)</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>服务端模块化（<code>Node.js</code> 原生支持）</td><td>浏览器与跨平台模块化（<code>ES6</code> 标准）</td></tr><tr><td><strong>加载方式</strong></td><td>动态加载（运行时解析）</td><td>静态加载（编译时解析）</td></tr><tr><td><strong>模块导入/导出语法</strong></td><td><code>require()</code> / <code>module.exports</code></td><td><code>import</code> / <code>export</code></td></tr><tr><td><strong>执行时机</strong></td><td>同步阻塞加载（运行时执行）</td><td>异步非阻塞加载（浏览器中，运行时执行）</td></tr><tr><td><strong>作用域</strong></td><td>模块内局部作用域</td><td>模块级词法作用域</td></tr><tr><td><strong>循环依赖处理</strong></td><td>支持但需谨慎处理</td><td>支持更安全的静态分析</td></tr><tr><td><strong>Tree Shaking</strong></td><td>不支持（动态特性导致难以静态分析）</td><td>天然支持（利于打包工具优化代码体积）</td></tr><tr><td><strong>浏览器兼容性</strong></td><td>需构建工具转换（如 <code>Webpack/Babel</code>）</td><td>现代浏览器原生支持</td></tr><tr><td><strong>Node.js 支持</strong></td><td>原生支持</td><td><code>.mjs</code> 扩展名或 <code>&quot;type&quot;: &quot;module&quot;</code></td></tr></tbody></table><h3 id="二、关键差异详解" tabindex="-1"><strong>二、关键差异详解</strong> <a class="header-anchor" href="#二、关键差异详解" aria-label="Permalink to &quot;**二、关键差异详解**&quot;">​</a></h3><h4 id="_1-加载机制" tabindex="-1">1. <strong>加载机制</strong> <a class="header-anchor" href="#_1-加载机制" aria-label="Permalink to &quot;1. **加载机制**&quot;">​</a></h4><ul><li><p><strong>CommonJS</strong> 虽然 <code>require()</code> 是同步的，但它仍具备动态加载能力：</p><ul><li><p><strong>动态加载</strong>：</p><ul><li><p>条件加载：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;development&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> debugTool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./debugTool&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态决定是否加载模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  debugTool.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Debug mode&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>动态路径：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态路径加载</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someCondition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;moduleA&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;moduleB&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`./\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">moduleName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.js\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路径动态生成，在代码执行时解析依赖。</span></span></code></pre></div></li></ul></li><li><p><strong>同步执行</strong>：模块加载会阻塞后续代码运行，适用于服务端文件系统。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// require() 阻塞后续代码执行，直到模块加载完成</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步加载，后续代码需等待</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Loaded fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ul></li><li><p><strong>ESM</strong></p><ul><li><p><strong>静态加载</strong>：依赖关系在代码解析阶段确定，路径必须是静态字符串。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 静态导入（不允许变量路径）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> moduleA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./moduleA.js&#39;</span></span></code></pre></div></li><li><p><strong>异步加载</strong>：浏览器中可通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 异步加载，不阻塞页面渲染。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import() 返回 Promise，支持非阻塞异步加载</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Loaded fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Loading fs...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先执行</span></span></code></pre></div></li></ul></li></ul><h4 id="_2-模块作用域与绑定" tabindex="-1">2. <strong>模块作用域与绑定</strong> <a class="header-anchor" href="#_2-模块作用域与绑定" aria-label="Permalink to &quot;2. **模块作用域与绑定**&quot;">​</a></h4><ul><li><p><strong>CommonJS</strong></p><ul><li><p><strong>值拷贝导出</strong>：导出的是模块的<strong>值拷贝</strong>，后续修改不影响原始模块。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// counter.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./counter.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 0（值未同步更新）</span></span></code></pre></div></li></ul></li><li><p><strong>ESM</strong></p><ul><li><p><strong>实时绑定导出</strong>：导出的是模块的<strong>引用绑定</strong>，修改会同步到所有导入方。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// counter.mjs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.mjs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count, increment } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./counter.mjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 1</span></span></code></pre></div></li></ul></li></ul><h4 id="_3-循环依赖处理" tabindex="-1">3. <strong>循环依赖处理</strong> <a class="header-anchor" href="#_3-循环依赖处理" aria-label="Permalink to &quot;3. **循环依赖处理**&quot;">​</a></h4><ul><li><p><strong>CommonJS</strong></p><ul><li><p>允许循环依赖，但可能导致未完全初始化的模块被访问。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./b.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a: b.value =&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b.value)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./a.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b: a.value =&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a.value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 undefined（a 未完成初始化）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul></li><li><p><strong>ESM</strong></p><ul><li><p>静态分析确保循环依赖安全，模块会先完成初始化再执行代码。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.mjs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./b.mjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;b&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.mjs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./a.mjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;a&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;b&#39;</span></span></code></pre></div></li></ul></li></ul><h4 id="_4-性能与优化" tabindex="-1">4. <strong>性能与优化</strong> <a class="header-anchor" href="#_4-性能与优化" aria-label="Permalink to &quot;4. **性能与优化**&quot;">​</a></h4><ul><li><p><strong>CommonJS</strong></p><ul><li><strong>启动速度慢</strong>：运行时解析依赖，无法预优化。</li><li><strong>内存占用高</strong>：模块多次加载时缓存副本。</li></ul></li><li><p><strong>ESM</strong></p><ul><li><strong>编译时优化</strong>：静态分析支持 <code>Tree Shaking</code>，减少打包体积。</li><li><strong>高效缓存</strong>：浏览器通过 <code>URL</code> 缓存模块，避免重复加载。</li></ul></li></ul><h4 id="_5-互操作性" tabindex="-1">5. <strong>互操作性</strong> <a class="header-anchor" href="#_5-互操作性" aria-label="Permalink to &quot;5. **互操作性**&quot;">​</a></h4><ul><li><strong>Node.js 中混合使用</strong><ul><li><p><strong>ESM 导入 CommonJS</strong>：可直接使用 <code>import</code> 导入 <code>CommonJS</code> 模块。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ESM 中导入 CommonJS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cjsModule </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./commonjs-module.js&#39;</span></span></code></pre></div></li><li><p><strong>CommonJS 导入 ESM</strong>：需使用动态 <code>import()</code>（异步）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CommonJS 中导入 ESM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadESM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> esmModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./esm-module.mjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li></ul><h3 id="三、使用场景推荐" tabindex="-1"><strong>三、使用场景推荐</strong> <a class="header-anchor" href="#三、使用场景推荐" aria-label="Permalink to &quot;**三、使用场景推荐**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>场景</strong></th><th><strong>推荐模块系统</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td><code>Node.js</code> 服务端开发</td><td><code>CommonJS</code></td><td>原生支持，生态成熟</td></tr><tr><td>浏览器端现代应用</td><td><code>ESM</code></td><td>原生支持，<code>Tree Shaking</code> 优化</td></tr><tr><td>跨平台库开发</td><td><code>ESM + CommonJS</code> 双导出</td><td>兼容新旧环境</td></tr><tr><td>代码分割与按需加载</td><td><code>ESM</code> 动态导入 (<code>import()</code>)</td><td>异步加载提升性能</td></tr><tr><td>旧项目维护</td><td><code>CommonJS</code></td><td>避免大规模重构成本</td></tr></tbody></table><h3 id="四、迁移与兼容性策略" tabindex="-1"><strong>四、迁移与兼容性策略</strong> <a class="header-anchor" href="#四、迁移与兼容性策略" aria-label="Permalink to &quot;**四、迁移与兼容性策略**&quot;">​</a></h3><ol><li><p><strong>Node.js 项目迁移</strong></p><ul><li>将文件扩展名改为 <code>.mjs</code> 或设置 <code>package.json</code> 中 <code>&quot;type&quot;: &quot;module&quot;</code>。</li><li>替换 <code>require()</code> 为 <code>import</code>，<code>module.exports</code> 为 <code>export</code>。</li></ul></li><li><p><strong>浏览器兼容处理</strong></p><ul><li>使用构建工具（如 <code>Webpack</code>、<code>Rollup</code>）将 <code>ESM</code> 转换为兼容旧浏览器的代码。</li></ul></li><li><p><strong>双模式支持库</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;exports&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;import&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./esm/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ESM 入口</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;require&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./cjs/index.js&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // CommonJS 入口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><h3 id="五、未来趋势" tabindex="-1"><strong>五、未来趋势</strong> <a class="header-anchor" href="#五、未来趋势" aria-label="Permalink to &quot;**五、未来趋势**&quot;">​</a></h3><ul><li><strong>ESM 主导</strong>：浏览器原生支持和现代工具链推动 <code>ESM</code> 成为主流。</li><li><strong>Node.js 过渡</strong>：<code>Node.js</code> 逐步增强 <code>ESM</code> 支持，但 <code>CommonJS</code> 仍长期存在。</li><li><strong>工具链统一</strong>：<code>Vite</code>、<code>Snowpack</code> 等工具默认采用 <code>ESM</code>，提升开发体验。</li></ul><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>CommonJS</strong>：适用于<strong>服务端</strong>和<strong>传统构建工具链</strong>，以动态加载和同步执行为特点，但缺乏静态优化能力。</li><li><strong>ESM</strong>：面向<strong>现代浏览器</strong>和<strong>跨平台开发</strong>，通过静态分析和实时绑定实现高效、安全的模块化，适合追求性能与优化的项目。</li></ul><p>根据项目需求选择模块系统：<strong>新项目优先使用 ESM</strong>，<strong>旧系统逐步迁移</strong>，<strong>工具库提供双模式支持</strong>以兼容不同环境。</p><h2 id="通过-import-多次引入同一模块-最终打包结果中只会引用一次" tabindex="-1">通过 <code>import</code> 多次引入同一模块，最终打包结果中只会引用一次 <a class="header-anchor" href="#通过-import-多次引入同一模块-最终打包结果中只会引用一次" aria-label="Permalink to &quot;通过 \`import\` 多次引入同一模块，最终打包结果中只会引用一次&quot;">​</a></h2><p>在 <code>ESM（ECMAScript Modules）</code> 模块系统中，如果通过 <code>import</code> 多次引入同一个依赖，<strong>最终的打包结果中通常只会引用一次该依赖</strong>。这是由模块系统的单例特性和现代打包工具的静态分析优化共同决定的。</p><h3 id="_1-esm-的单例特性" tabindex="-1"><strong>1. ESM 的单例特性</strong> <a class="header-anchor" href="#_1-esm-的单例特性" aria-label="Permalink to &quot;**1. ESM 的单例特性**&quot;">​</a></h3><br><p><code>ESM</code> 规范强制要求模块是 <strong>单例（Singleton）</strong> 的，即：</p><ul><li><strong>模块只会执行一次</strong>：无论从多少文件导入同一模块，该模块的代码只会初始化并执行一次。</li><li><strong>共享同一实例</strong>：所有 <code>import</code> 语句最终都指向同一个模块实例，变量、状态、副作用代码（如全局修改）均共享。</li></ul><p>例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// moduleA.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Module A loaded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只会执行一次</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// file1.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./moduleA.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 42</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// file2.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./moduleA.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 42</span></span></code></pre></div><blockquote><p>无论从多少文件导入 <code>moduleA</code>，其代码只会执行一次，<code>value</code> 也只会初始化一次。</p></blockquote><h3 id="_2-打包工具的静态分析优化" tabindex="-1"><strong>2. 打包工具的静态分析优化</strong> <a class="header-anchor" href="#_2-打包工具的静态分析优化" aria-label="Permalink to &quot;**2. 打包工具的静态分析优化**&quot;">​</a></h3><br><p>现代打包工具（如 <code>Webpack</code>、<code>Rollup</code>、<code>Vite</code> 等）会对模块进行 <strong>静态分析</strong> 和 <strong>依赖关系树扁平化（Tree Shaking &amp; Hoisting）</strong>：</p><ul><li><strong>代码合并</strong>：所有对同一模块的 <code>import</code> 会被合并为一次引用。</li><li><strong>消除重复代码</strong>：如果模块被多次引入，打包工具会确保模块代码在最终产物中仅保留一份。</li></ul><h3 id="示例如下" tabindex="-1">示例如下 <a class="header-anchor" href="#示例如下" aria-label="Permalink to &quot;示例如下&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// moduleA.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入口文件 index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./moduleA.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { b } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./moduleA.js&#39;</span></span></code></pre></div><h4 id="打包后结果-伪代码" tabindex="-1">打包后结果（伪代码） <a class="header-anchor" href="#打包后结果-伪代码" aria-label="Permalink to &quot;打包后结果（伪代码）&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后的模块A代码（仅保留一份）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __moduleA_exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入口文件逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__moduleA_exports.a)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__moduleA_exports.b)</span></span></code></pre></div><h3 id="_3-特殊情况" tabindex="-1"><strong>3. 特殊情况</strong> <a class="header-anchor" href="#_3-特殊情况" aria-label="Permalink to &quot;**3. 特殊情况**&quot;">​</a></h3><ul><li><p>动态导入（Dynamic Import）</p><p>如果通过 <code>import()</code> 动态导入同一模块多次，浏览器会缓存模块，代码仍只会执行一次：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态导入会返回同一个 Promise</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div></li><li><p>副作用（Side Effects）</p><p>如果模块包含立即执行的副作用代码（如修改全局状态），这些代码也只会执行一次：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// moduleWithSideEffect.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.globalConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { env: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;prod&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ul><h3 id="_4-验证工具行为" tabindex="-1"><strong>4. 验证工具行为</strong> <a class="header-anchor" href="#_4-验证工具行为" aria-label="Permalink to &quot;**4. 验证工具行为**&quot;">​</a></h3><br><p>可以通过以下方式验证打包结果：</p><ol><li><strong>查看打包产物</strong>：使用 <code>Webpack</code> 的 <code>stats</code> 分析或 <code>Rollup</code> 的代码输出，观察模块是否重复。</li><li><strong>性能工具检测</strong>：在浏览器中通过 <code>Network</code> 面板确认模块是否多次加载（SPA 中通常不会）。</li></ol><h3 id="底层原理" tabindex="-1"><strong>底层原理</strong> <a class="header-anchor" href="#底层原理" aria-label="Permalink to &quot;**底层原理**&quot;">​</a></h3><ul><li><strong>模块缓存机制</strong>：<br> 浏览器和打包工具内部会维护一个模块缓存（如 <code>Module Map</code>），首次加载模块后，后续导入直接读取缓存。</li><li><strong>静态分析优化</strong>：<br> 打包工具通过分析代码的导入导出关系，将同一模块的多次引用映射到同一份代码，避免重复打包。</li></ul><h3 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td>静态 <code>import</code> 多次引入同一模块</td><td>代码保留一份，单例引用</td><td><code>ESM</code> 规范 + 打包工具优化</td></tr><tr><td>动态 <code>import()</code> 多次加载模块</td><td>代码保留一份，单例引用</td><td>浏览器模块缓存机制</td></tr><tr><td>模块包含副作用代码</td><td><strong>副作用代码仅执行一次</strong></td><td>单例特性保证</td></tr></tbody></table><p><strong>最佳实践</strong>：无需担心多次 <code>import</code> 同一模块的性能问题，打包工具会优化冗余代码。但需避免无意义的重复导入以保持代码可读性。</p><h2 id="commonjs、esm-和-amd-的对比" tabindex="-1">CommonJS、ESM 和 AMD 的对比 <a class="header-anchor" href="#commonjs、esm-和-amd-的对比" aria-label="Permalink to &quot;CommonJS、ESM 和 AMD 的对比&quot;">​</a></h2><p>在 <code>JavaScript</code> 生态中，<strong>CommonJS</strong>、<strong>ESM（ES Modules）</strong> 和 <strong>AMD（Asynchronous Module Definition）</strong> 是三种主流的模块化规范，它们解决了代码组织、依赖管理和加载的问题，但设计目标和适用场景有所不同。</p><h3 id="_1-commonjs" tabindex="-1"><strong>1. CommonJS</strong> <a class="header-anchor" href="#_1-commonjs" aria-label="Permalink to &quot;**1. CommonJS**&quot;">​</a></h3><h4 id="特点" tabindex="-1">特点： <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点：&quot;">​</a></h4><ul><li><p><strong>同步加载</strong>：模块在运行时<strong>同步加载</strong>（适合服务端）。</p></li><li><p><strong>语法</strong>：<code>require()</code> 引入模块，<code>module.exports</code> 或 <code>exports</code> 导出模块。</p></li><li><p><strong>适用场景</strong>：<code>Node.js</code> 的默认模块系统，主要用于服务端开发。</p></li><li><p><strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导出</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { myFunction }</span></span></code></pre></div></li></ul><h4 id="关键点" tabindex="-1">关键点： <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;关键点：&quot;">​</a></h4><ul><li><strong>模块缓存</strong>：模块首次加载后会被缓存，后续调用 <code>require()</code> 直接读取缓存。</li><li><strong>动态性</strong>：依赖关系在运行时确定，支持条件加载。</li><li><strong>局限性</strong>：同步加载不适合浏览器环境（会阻塞渲染）。</li></ul><h3 id="_2-esm-es-modules" tabindex="-1"><strong>2. ESM（ES Modules）</strong> <a class="header-anchor" href="#_2-esm-es-modules" aria-label="Permalink to &quot;**2. ESM（ES Modules）**&quot;">​</a></h3><h4 id="特点-1" tabindex="-1">特点： <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点：&quot;">​</a></h4><ul><li><p><strong>静态分析</strong>：依赖在编译时确定，支持<strong>静态优化</strong>（如 <code>Tree Shaking</code>）。</p></li><li><p><strong>语法</strong>：<code>import</code> 和 <code>export</code> 关键字。</p></li><li><p><strong>适用场景</strong>：现代浏览器和构建工具（如 <code>Webpack、Rollup</code>）的官方标准。</p></li><li><p><strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { func } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span></code></pre></div></li></ul><h4 id="关键点-1" tabindex="-1">关键点： <a class="header-anchor" href="#关键点-1" aria-label="Permalink to &quot;关键点：&quot;">​</a></h4><ul><li><strong>异步加载</strong>：浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 异步加载。</li><li><strong>严格模式</strong>：默认启用严格模式。</li><li><strong>浏览器兼容性</strong>：现代浏览器原生支持，旧浏览器需通过构建工具转译。</li><li><strong>Node.js 支持</strong>：<code>Node v12+</code> 通过 <code>.mjs</code> 扩展名或 <code>package.json</code> 的 <code>&quot;type&quot;: &quot;module&quot;</code> 启用。</li></ul><h3 id="_3-amd-asynchronous-module-definition" tabindex="-1"><strong>3. AMD（Asynchronous Module Definition）</strong> <a class="header-anchor" href="#_3-amd-asynchronous-module-definition" aria-label="Permalink to &quot;**3. AMD（Asynchronous Module Definition）**&quot;">​</a></h3><h4 id="特点-2" tabindex="-1">特点： <a class="header-anchor" href="#特点-2" aria-label="Permalink to &quot;特点：&quot;">​</a></h4><ul><li><p><strong>异步加载</strong>：专为浏览器设计，<strong>非阻塞加载</strong>模块。</p></li><li><p><strong>语法</strong>：通过 <code>define()</code> 定义模块，<code>require()</code> 异步加载。</p></li><li><p><strong>适用场景</strong>：传统浏览器端项目（如 <code>RequireJS</code> 库）。</p></li><li><p><strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dep1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dep2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dep1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dep2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { myFunction }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {})</span></span></code></pre></div></li></ul><h4 id="关键点-2" tabindex="-1">关键点： <a class="header-anchor" href="#关键点-2" aria-label="Permalink to &quot;关键点：&quot;">​</a></h4><ul><li><strong>依赖前置</strong>：模块依赖需提前声明。</li><li><strong>动态加载</strong>：适合按需加载的复杂前端应用。</li><li><strong>复杂性</strong>：配置和语法相对繁琐。</li></ul><h3 id="对比总结" tabindex="-1"><strong>对比总结</strong> <a class="header-anchor" href="#对比总结" aria-label="Permalink to &quot;**对比总结**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th><code>CommonJS</code></th><th><code>ESM</code></th><th><code>AMD</code></th></tr></thead><tbody><tr><td><strong>加载方式</strong></td><td>同步（服务端）</td><td>静态/异步（浏览器）</td><td>异步（浏览器）</td></tr><tr><td><strong>语法</strong></td><td><code>require/exports</code></td><td><code>import/export</code></td><td><code>define/require</code></td></tr><tr><td><strong>运行环境</strong></td><td><code>Node.js</code></td><td>浏览器/<code>Node.js</code></td><td>浏览器</td></tr><tr><td><strong>静态分析</strong></td><td>不支持</td><td>支持（<code>Tree Shaking</code>）</td><td>不支持</td></tr><tr><td><strong>循环依赖处理</strong></td><td>支持</td><td>支持</td><td>复杂</td></tr><tr><td><strong>典型工具/库</strong></td><td><code>Node.js</code></td><td><code>Webpack</code>, <code>Rollup</code></td><td><code>RequireJS</code></td></tr></tbody></table><h3 id="演进与现状" tabindex="-1"><strong>演进与现状</strong> <a class="header-anchor" href="#演进与现状" aria-label="Permalink to &quot;**演进与现状**&quot;">​</a></h3><ol><li><strong>ESM 是未来</strong>：作为 <code>ECMAScript</code> 标准，<code>ESM</code> 逐渐统一浏览器和 <code>Node.js</code> 的模块化方案。</li><li><strong>Node.js 的双模块</strong>：<code>Node.js</code> 同时支持 <code>CommonJS</code> 和 <code>ESM</code>（需配置），但两者混用需谨慎（如 <code>import</code> 无法直接引入 <code>CommonJS</code> 模块的具名导出）。</li><li><strong>AMD 的淡出</strong>：随着 <code>ESM</code> 的普及和构建工具的成熟，<code>AMD</code> 主要用于旧项目维护。</li></ol><h3 id="如何选择" tabindex="-1"><strong>如何选择？</strong> <a class="header-anchor" href="#如何选择" aria-label="Permalink to &quot;**如何选择？**&quot;">​</a></h3><ul><li><strong>现代前端项目</strong>：优先使用 <strong>ESM</strong>（通过 <code>Webpack/Rollup</code> 打包）。</li><li><strong>Node.js 服务端</strong>：<code>CommonJS</code> 仍是主流，但新项目推荐逐步迁移到 <code>ESM</code>。</li><li><strong>旧浏览器兼容</strong>：<code>AMD</code> 或 <code>ESM +</code> 构建工具降级处理。</li></ul><p>理解这些规范的差异，有助于在不同场景下合理组织代码和优化加载性能。</p>`,94)])])}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
