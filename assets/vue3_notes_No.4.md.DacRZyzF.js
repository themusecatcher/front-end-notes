import{_ as t,C as a,c as o,o as l,j as s,G as n,ac as d,a as r}from"./chunks/framework.CtEZafqV.js";const b=JSON.parse('{"title":"Note 4","description":"","frontmatter":{},"headers":[],"relativePath":"vue3/notes/No.4.md","filePath":"vue3/notes/No.4.md","lastUpdated":1764661331000}'),h={name:"vue3/notes/No.4.md"};function c(p,e,g,k,u,E){const i=a("BackTop");return l(),o("div",null,[e[0]||(e[0]=s("h1",{id:"note-4",tabindex:"-1"},[r("Note 4 "),s("a",{class:"header-anchor",href:"#note-4","aria-label":'Permalink to "Note 4"'},"​")],-1)),n(i),e[1]||(e[1]=d('<h2 id="vue3-的状态管理-pinia" tabindex="-1"><code>Vue3</code> 的状态管理 <a href="https://pinia.vuejs.org/zh/" target="_blank" rel="noreferrer"><code>Pinia</code></a> <a class="header-anchor" href="#vue3-的状态管理-pinia" aria-label="Permalink to &quot;`Vue3` 的状态管理 [`Pinia`](https://pinia.vuejs.org/zh/)&quot;">​</a></h2><p>核心机制并非传统意义上的 <strong>发布订阅模式（Pub-Sub）</strong>，而是基于 <strong>Vue3 的响应式系统</strong>（Reactivity System）实现的。</p><h3 id="_1-核心机制-响应式系统" tabindex="-1"><strong>1. 核心机制：响应式系统</strong> <a class="header-anchor" href="#_1-核心机制-响应式系统" aria-label="Permalink to &quot;**1. 核心机制：响应式系统**&quot;">​</a></h3><br><p><code>Pinia</code> 的底层依赖于 <code>Vue3</code> 的 <code>reactive</code> 和 <code>ref</code> 等响应式 <code>API</code>，其核心原理是通过 <strong>依赖追踪（Dependency Tracking）</strong> 和 <strong>触发更新（Trigger Updates）</strong> 实现状态管理。具体流程如下：</p><ol><li><p><strong>状态定义</strong>：<br> 使用 <code>defineStore</code> 创建 Store，内部状态（<code>state</code>）会被转换为响应式对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> useStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storeId&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actions: {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p><strong>依赖收集</strong>：<br> 当组件中通过 <code>useStore()</code> 访问状态（如 <code>store.count</code>）时，<code>Vue3</code> 会通过 <code>Proxy</code> 自动追踪这些属性的依赖关系，将当前组件注册为这些状态的“订阅者”。</p></li><li><p><strong>触发更新</strong>：<br> 当状态变更时（如调用 <code>store.increment()</code>），响应式系统会通知所有依赖该状态的组件重新渲染。</p></li></ol><h3 id="_2-与传统发布订阅模式的区别" tabindex="-1"><strong>2. 与传统发布订阅模式的区别</strong> <a class="header-anchor" href="#_2-与传统发布订阅模式的区别" aria-label="Permalink to &quot;**2. 与传统发布订阅模式的区别**&quot;">​</a></h3><br><p>虽然 <code>Pinia</code> 的状态变更会触发组件更新，但其机制与典型的发布订阅模式有以下关键差异：</p><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>Pinia（响应式系统）</strong></th><th><strong>发布订阅模式</strong></th></tr></thead><tbody><tr><td><strong>通信方式</strong></td><td>隐式依赖追踪，自动绑定依赖关系</td><td>显式订阅事件，手动管理订阅关系</td></tr><tr><td><strong>耦合性</strong></td><td>组件与状态直接绑定，无需手动订阅</td><td>发布者和订阅者解耦，通过事件通道通信</td></tr><tr><td><strong>性能优化</strong></td><td>依赖 <code>Vue</code> 的响应式优化（如惰性更新）</td><td>需自行实现事件过滤或节流</td></tr><tr><td><strong>典型场景</strong></td><td>状态驱动 <code>UI</code> 更新</td><td>跨组件或跨层级的松散耦合通信</td></tr></tbody></table><h3 id="_3-为什么-pinia-不直接使用发布订阅" tabindex="-1"><strong>3. 为什么 <code>Pinia</code> 不直接使用发布订阅？</strong> <a class="header-anchor" href="#_3-为什么-pinia-不直接使用发布订阅" aria-label="Permalink to &quot;**3. 为什么 `Pinia` 不直接使用发布订阅？**&quot;">​</a></h3><ol><li><strong>与 Vue 生态深度集成</strong>：<br><code>Vue</code> 的响应式系统天然支持自动依赖追踪，无需手动维护订阅关系，简化了开发流程。</li><li><strong>性能优势</strong>：<br> 响应式系统通过细粒度依赖追踪（如基于 <code>Proxy</code> 的监听），仅在相关状态变化时触发更新，避免了传统 <code>Pub-Sub</code> 中可能存在的无效通知。</li><li><strong>开发体验优化</strong>：<br> 开发者无需手动订阅/取消订阅，减少了内存泄漏风险，代码更简洁。</li></ol><h3 id="_4-补充-pinia-中的-类发布订阅-行为" tabindex="-1"><strong>4. 补充：Pinia 中的“类发布订阅”行为</strong> <a class="header-anchor" href="#_4-补充-pinia-中的-类发布订阅-行为" aria-label="Permalink to &quot;**4. 补充：Pinia 中的“类发布订阅”行为**&quot;">​</a></h3><br><p>尽管核心机制不同，<code>Pinia</code> 仍提供了一些类似发布订阅的 API，用于特定场景：</p><ol><li><p><strong><code>store.$subscribe()</code></strong>：<br> 监听 <code>Store</code> 中状态的变更（类似订阅全局状态变化事件）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;状态变更:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mutation.type, state)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p><strong><code>store.$onAction()</code></strong>： 监听 <code>Action</code> 的执行（类似订阅动作触发事件）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$onAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">onError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Action 触发:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name, args)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li></ol><h3 id="_5-总结" tabindex="-1"><strong>5. 总结</strong> <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;**5. 总结**&quot;">​</a></h3><ul><li><strong><code>Pinia</code> 的核心机制是响应式系统</strong>，而非传统发布订阅模式。</li><li>其优势在于 <strong>自动依赖追踪</strong> 和 <strong>与 <code>Vue</code> 生态的无缝集成</strong>，避免了手动管理订阅关系的复杂性。</li><li>在需要跨组件通信或非响应式场景时，可结合 <code>Vue</code> 的 <code>provide/inject</code> 或第三方 <code>Pub-Sub</code> 库（如 <code>mitt</code>）扩展功能。</li></ul><h2 id="虚拟-dom" tabindex="-1"><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism#virtual-dom" target="_blank" rel="noreferrer">虚拟 DOM</a> <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;[虚拟 DOM](https://cn.vuejs.org/guide/extras/rendering-mechanism#virtual-dom)&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">总的来说，可以归结为以下两点:</p><ol><li>框架设计</li><li>解耦运行时环境</li></ol></div><p><code>Virtual DOM</code> 是对 <code>DOM</code> 的抽象，本质上是 <code>JavaScript</code> 对象</p><p><code>Virtual DOM</code> 是一棵以 <code>JavaScript</code> 对象作为基础的树，每一个节点称为 <code>VNode</code>，用对象属性来描述节点，实际上它是一层对真实 <code>DOM</code> 的抽象，最终可以<strong>通过渲染操作使这棵树映射到真实环境上</strong>，简单来说 <code>Virtual DOM</code> 就是一个 <code>JS</code> 对象，用以描述整个文档。</p><h3 id="virtual-dom-的优势" tabindex="-1"><code>Virtual DOM</code> 的优势 <a class="header-anchor" href="#virtual-dom-的优势" aria-label="Permalink to &quot;`Virtual DOM` 的优势&quot;">​</a></h3><ol><li>操作 <code>DOM</code> 慢，<code>JS</code> 运行效率高，提高效率。 因为 <code>DOM</code> 操作的执行速度远不如 <code>Javascript</code> 的运算速度快，因此，把大量的 <code>DOM</code> 操作搬运到 <code>JavaScript</code> 中，运用 <code>patching</code> 算法来计算出真正需要更新的节点，能最大限度地减少 <code>DOM</code> 操作，从而显著提高性能。</li></ol><blockquote><p>本质上就是在 <code>JS</code> 和 <code>DOM</code> 之间做了一个缓存。</p></blockquote><ol start="2"><li>提升渲染性能，<code>Virtual DOM</code> 的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。 和 <code>DOM</code> 操作比起来，<code>js</code> 计算是极其便宜的。这才是为什么要有 <code>Virtual DOM</code>，它保证了</li></ol><ul><li>不管你的数据变化多少，每次重绘的性能都可以接受</li><li>依然可以用类似 <code>innerHTML</code> 的思路去写你的应用</li></ul><h3 id="virtual-dom-的真正价值不是性能-而在于" tabindex="-1"><code>Virtual DOM</code> 的真正价值不是性能，而在于： <a class="header-anchor" href="#virtual-dom-的真正价值不是性能-而在于" aria-label="Permalink to &quot;`Virtual DOM` 的真正价值不是性能，而在于：&quot;">​</a></h3><ol><li>为函数式的 <code>UI</code> 编程方式打开了大门</li><li>可以将 <code>JS</code> 对象渲染到浏览器 <code>DOM</code> 以外的 <code>backend</code>（环境中），也就是支持了跨平台的开发，比如 <code>ReactNative</code> 就是基于 <code>React</code> 的跨平台开发框架。</li></ol><h3 id="vue-中的-虚拟-dom" tabindex="-1"><code>Vue</code> 中的 <code>虚拟 DOM</code> <a class="header-anchor" href="#vue-中的-虚拟-dom" aria-label="Permalink to &quot;`Vue` 中的 `虚拟 DOM`&quot;">​</a></h3><br><p>在 <code>Vue.js</code> 中，<strong>虚拟 DOM（Virtual DOM）</strong> 是框架实现高效渲染的核心机制。它通过抽象真实 <code>DOM</code> 的复杂性，结合 <code>Diff</code> 算法和批量更新策略，显著提升了 <code>Web</code> 应用的性能表现。</p><h3 id="一、虚拟-dom-的本质" tabindex="-1">一、虚拟 DOM 的本质 <a class="header-anchor" href="#一、虚拟-dom-的本质" aria-label="Permalink to &quot;一、虚拟 DOM 的本质&quot;">​</a></h3><ol><li><strong>轻量级 JavaScript 对象</strong> <br> 虚拟 <code>DOM</code> 是真实 <code>DOM</code> 的抽象表示，本质是一个包含节点类型、属性、子节点等信息的 <strong>普通 JS 对象</strong>。例如：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vnode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, class: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  children: [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello Vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>与真实 DOM 的关键区别</strong></li></ol><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>真实 DOM</strong></th><th><strong>虚拟 DOM</strong></th></tr></thead><tbody><tr><td>操作代价</td><td>昂贵（触发重绘/回流）</td><td>轻量（仅 <code>JS</code> 对象操作）</td></tr><tr><td>更新策略</td><td>直接修改</td><td>批量 <code>Diff</code> 后更新</td></tr><tr><td>平台依赖性</td><td>强（浏览器环境）</td><td>跨平台（如 <code>SSR</code>、小程序）</td></tr></tbody></table><h3 id="二、虚拟-dom-的核心工作流程" tabindex="-1">二、虚拟 DOM 的核心工作流程 <a class="header-anchor" href="#二、虚拟-dom-的核心工作流程" aria-label="Permalink to &quot;二、虚拟 DOM 的核心工作流程&quot;">​</a></h3><h4 id="_1-初始化阶段" tabindex="-1">1. <strong>初始化阶段</strong> <a class="header-anchor" href="#_1-初始化阶段" aria-label="Permalink to &quot;1. **初始化阶段**&quot;">​</a></h4><ul><li><p><strong>模板编译</strong>：将 <code>Vue</code> 模板（<code>.vue</code> 文件或 <code>template</code> 选项）编译为 <strong>渲染函数（render function）</strong></p></li><li><p><strong>生成虚拟 DOM</strong>：首次渲染时，执行渲染函数生成初始虚拟 <code>DOM</code> 树</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后的渲染函数示例</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(h) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h4 id="_2-更新阶段" tabindex="-1">2. <strong>更新阶段</strong> <a class="header-anchor" href="#_2-更新阶段" aria-label="Permalink to &quot;2. **更新阶段**&quot;">​</a></h4><ul><li><strong>数据变更触发</strong>：当响应式数据变化时，重新执行渲染函数生成 <strong>新虚拟 DOM 树</strong></li><li><strong><code>Diff</code> 算法（差异对比）</strong>：对比新旧虚拟 <code>DOM</code> 树，找出最小变更集（同级比较、<code>Key</code> 优化等）</li><li><strong>批量更新真实 <code>DOM</code></strong>：通过 <strong>patch 函数</strong> 将差异应用到真实 <code>DOM</code>，避免频繁重绘/回流</li></ul><h3 id="三、diff-算法的核心优化策略" tabindex="-1">三、<code>Diff</code> 算法的核心优化策略 <a class="header-anchor" href="#三、diff-算法的核心优化策略" aria-label="Permalink to &quot;三、`Diff` 算法的核心优化策略&quot;">​</a></h3><br><p><code>Vue</code> 的 <code>Diff</code> 算法通过以下策略减少计算量（时间复杂度 <code>O(n)</code>）：</p><ol><li><strong>同层级比较</strong></li></ol><ul><li>仅比较同一层级的节点，不跨层级移动（减少递归深度）</li></ul><ol start="2"><li><strong>Key 的作用</strong></li></ol><ul><li>通过唯一 <code>key</code> 标识节点身份，复用相同 <code>Key</code> 的 <code>DOM</code> 元素（避免不必要的销毁/重建）</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 列表渲染时推荐使用唯一 Key --&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item in list&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item.id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ item.text }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="3"><li><strong>双端指针优化</strong></li></ol><ul><li>在新旧子节点数组的首尾设置指针，优先处理头尾相同节点（减少遍历次数）</li></ul><h3 id="四、虚拟-dom-的性能优势与代价" tabindex="-1">四、虚拟 DOM 的性能优势与代价 <a class="header-anchor" href="#四、虚拟-dom-的性能优势与代价" aria-label="Permalink to &quot;四、虚拟 DOM 的性能优势与代价&quot;">​</a></h3><h4 id="优势" tabindex="-1"><strong>优势</strong> <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;**优势**&quot;">​</a></h4><ol><li><strong>减少直接 DOM 操作</strong> 批量合并多次数据变更，避免频繁触发浏览器渲染机制（如 <strong>100 次数据变化 → 1 次 DOM 更新</strong>）。</li><li><strong>跨平台能力</strong> 虚拟 <code>DOM</code> 抽象了平台差异，使得 <code>Vue</code> 可适配不同渲染目标（如 <code>Web</code>、<code>Native</code>、<code>Canvas</code>）。</li><li><strong>开发体验优化</strong> 开发者无需手动优化 <code>DOM</code> 操作，专注于数据逻辑。</li></ol><h4 id="代价" tabindex="-1"><strong>代价</strong> <a class="header-anchor" href="#代价" aria-label="Permalink to &quot;**代价**&quot;">​</a></h4><ol><li><strong>内存占用</strong> 需额外存储虚拟 <code>DOM</code> 树，对低性能设备可能产生压力。</li><li><strong>初始渲染开销</strong><br> 首次渲染需经过模板编译 → <code>虚拟 DOM</code> → <code>真实 DOM</code> 的转换流程，比纯字符串拼接稍慢。</li><li><strong>极端场景性能瓶颈</strong><br> 超大规模动态列表或高频更新场景（如股票行情），需手动优化（如虚拟滚动）。</li></ol><h3 id="五、虚拟-dom-在-vue-3-中的优化" tabindex="-1">五、虚拟 DOM 在 Vue 3 中的优化 <a class="header-anchor" href="#五、虚拟-dom-在-vue-3-中的优化" aria-label="Permalink to &quot;五、虚拟 DOM 在 Vue 3 中的优化&quot;">​</a></h3><br><p><code>Vue 3</code> 对虚拟 <code>DOM</code> 进行了多项改进：</p><ol><li><strong>静态提升（Static Hoisting）</strong></li></ol><ul><li>将静态节点提取到渲染函数外部，避免重复创建：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _hoisted_1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /*#__PURE__*/</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_createVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Static Content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* HOISTED */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol start="2"><li><strong>Patch Flag 标记</strong></li></ol><ul><li>在虚拟 <code>DOM</code> 节点中标记动态属性类型（如 <code>class</code>、<code>style</code>），<code>Diff</code> 时跳过静态内容：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">patchFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1 表示只有文本内容是动态的</span></span></code></pre></div><ol start="3"><li><strong>缓存事件处理函数</strong></li></ol><ul><li>避免每次渲染重新生成事件回调，减少不必要的更新。</li></ul><h3 id="六、虚拟-dom-应用场景与最佳实践" tabindex="-1">六、虚拟 DOM 应用场景与最佳实践 <a class="header-anchor" href="#六、虚拟-dom-应用场景与最佳实践" aria-label="Permalink to &quot;六、虚拟 DOM 应用场景与最佳实践&quot;">​</a></h3><h4 id="适用场景" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h4><ul><li>中大型动态应用（频繁数据更新）</li><li>跨平台开发（如 <code>Vue Native</code>、<code>SSR</code>）</li><li>需要复杂交互的组件（如表单、拖拽）</li></ul><h4 id="规避性能陷阱" tabindex="-1"><strong>规避性能陷阱</strong> <a class="header-anchor" href="#规避性能陷阱" aria-label="Permalink to &quot;**规避性能陷阱**&quot;">​</a></h4><ol><li><strong>避免滥用大型虚拟 DOM 树</strong></li></ol><ul><li>使用 <code>v-show</code> 替代 <code>v-if</code> 控制频繁切换的组件</li><li>拆分复杂组件为多个子组件（利用局部更新特性）</li></ul><ol start="2"><li><strong>合理使用 Key</strong></li></ol><ul><li>列表项必须设置唯一且稳定的 <code>Key</code>，避免使用索引</li></ul><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 错误示例 --&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item, index) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="3"><li><strong>手动优化高频更新</strong></li></ol><ul><li>使用 <code>v-once</code> 标记静态内容</li><li>对动画场景使用 <code>CSS3</code> 或 <code>WebGL</code> 直接操作 <code>DOM</code></li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><br><p>虚拟 <code>DOM</code> 是 <code>Vue</code> 实现高效渲染的基石，通过 <code>Diff</code> 算法和批量更新策略，在开发便利性与性能之间取得了平衡。理解其工作原理（尤其是 <code>Key</code> 机制和 <code>Diff</code> 策略）能帮助开发者编写更高效的 <code>Vue</code> 代码。对于特殊性能场景，可结合 <code>Vue</code> 提供的优化工具（如 <code>v-memo</code>、<code>&lt;KeepAlive&gt;</code>）或直接操作 <code>DOM</code> 进行针对性优化。</p><h2 id="vue2-和-vue3-的-diff-算法区别" tabindex="-1"><code>Vue2</code> 和 <code>Vue3</code> 的 <code>Diff</code> 算法区别 <a class="header-anchor" href="#vue2-和-vue3-的-diff-算法区别" aria-label="Permalink to &quot;`Vue2` 和 `Vue3` 的 `Diff` 算法区别&quot;">​</a></h2><p><code>Vue2</code> 和 <code>Vue3</code> 的 <code>Diff</code> 算法在核心策略和性能优化上存在显著差异，这些改进使得 <code>Vue3</code> 在处理复杂场景时更高效。</p><h3 id="_1-核心算法策略" tabindex="-1">1. <strong>核心算法策略</strong> <a class="header-anchor" href="#_1-核心算法策略" aria-label="Permalink to &quot;1. **核心算法策略**&quot;">​</a></h3><ul><li><strong>Vue2</strong>：采用<strong>双端比较（双指针）算法</strong>，通过头尾四个指针（<code>oldStart</code>、<code>oldEnd</code>、<code>newStart</code>、<code>newEnd</code>）逐层比较新旧子节点列表，尝试复用节点并减少移动次数。若无法匹配，则通过遍历查找可复用节点，时间复杂度为 <strong>O(n³)</strong> 。</li><li><strong>Vue3</strong>：引入<strong>动态规划</strong>与<strong>最长递增子序列 LIS</strong>优化，先处理相同的前/后置节点，再对剩余节点构建映射表并计算最长递增子序列，从而减少节点移动次数。时间复杂度优化至 <strong>O(n²)</strong> 或更低。</li></ul><h3 id="_2-静态内容处理" tabindex="-1">2. <strong>静态内容处理</strong> <a class="header-anchor" href="#_2-静态内容处理" aria-label="Permalink to &quot;2. **静态内容处理**&quot;">​</a></h3><ul><li><strong>Vue2</strong>：静态节点在首次渲染后仍需参与 <code>Diff</code> 比较，无法完全跳过更新，导致冗余计算。</li><li><strong>Vue3</strong>：通过<strong>静态提升（Hoisting）<strong>将模板中的静态节点提取到外层作用域，后续更新时直接复用，无需比较。此外，引入</strong>块树 Block Tree</strong>概念，跳过静态块的 <code>Diff</code> 过程，大幅减少计算量。</li></ul><h3 id="_3-动态节点优化" tabindex="-1">3. <strong>动态节点优化</strong> <a class="header-anchor" href="#_3-动态节点优化" aria-label="Permalink to &quot;3. **动态节点优化**&quot;">​</a></h3><ul><li><strong>Vue2</strong>：动态节点的更新需全量比较属性、事件和子节点，即使仅部分内容变化。</li><li><strong>Vue3</strong>：通过<strong>PatchFlag 标记</strong>动态节点，例如文本变化、属性更新等。<code>Diff</code> 时仅检查标记的字段，跳过无关属性的比较。例如，仅文本变化的节点会标记为 <code>TEXT</code> 类型，无需遍历属性。</li></ul><h3 id="_4-数据结构支持" tabindex="-1">4. <strong>数据结构支持</strong> <a class="header-anchor" href="#_4-数据结构支持" aria-label="Permalink to &quot;4. **数据结构支持**&quot;">​</a></h3><ul><li><strong>Vue2</strong>：不支持多根节点（<code>Fragment</code>），每个组件必须包裹在单一根节点中。</li><li><strong>Vue3</strong>：原生支持<strong>Fragment</strong>（多根节点）和<strong>Teleport</strong>（跨 <code>DOM</code> 渲染），<code>Diff</code> 算法针对这些结构进行了优化，减少层级嵌套带来的性能损耗。</li></ul><h3 id="_5-列表-diff-的改进" tabindex="-1">5. <strong>列表 Diff 的改进</strong> <a class="header-anchor" href="#_5-列表-diff-的改进" aria-label="Permalink to &quot;5. **列表 Diff 的改进**&quot;">​</a></h3><ul><li><strong>Vue2</strong>：在处理乱序列表时，可能因频繁移动节点导致性能下降，尤其在无 <code>key</code> 时采用就地复用策略，易引发渲染错误。</li><li><strong>Vue3</strong>：结合 <code>key</code> 值和<strong>位置映射表</strong>，通过 <code>LIS</code> 算法确定最少移动次数。例如，若新列表顺序为 <code>b, c, a</code>，<code>Vue3</code> 会优先复用旧节点并按需移动，而非全量重建。</li></ul><h3 id="_6-编译时优化" tabindex="-1">6. <strong>编译时优化</strong> <a class="header-anchor" href="#_6-编译时优化" aria-label="Permalink to &quot;6. **编译时优化**&quot;">​</a></h3><ul><li><code>Vue3</code> 的编译器在构建阶段分析模板，提取动态部分并生成优化后的虚拟 <code>DOM</code> 结构。例如： <ul><li><strong>缓存事件处理函数</strong>，避免重复创建。</li><li><strong>静态属性提升</strong>，将不变的属性直接绑定到外层，减少 <code>Diff</code> 范围。</li></ul></li></ul><h3 id="性能对比" tabindex="-1">性能对比 <a class="header-anchor" href="#性能对比" aria-label="Permalink to &quot;性能对比&quot;">​</a></h3><ul><li><strong>基准测试</strong>：<code>Vue3</code> 的渲染性能比 <code>Vue2</code> 提升约 <code>100%-200%</code>，尤其在大型应用中表现更优。</li><li><strong>场景示例</strong>：对于包含大量动态列表的组件，<code>Vue3</code> 的 <code>PatchFlag</code> 和 <code>LIS</code> 优化可减少 <code>50%</code> 以上的 <code>DOM</code> 操作。</li></ul><h3 id="详细对比分析" tabindex="-1">详细对比分析 <a class="header-anchor" href="#详细对比分析" aria-label="Permalink to &quot;详细对比分析&quot;">​</a></h3><br><p><code>Vue</code> 的 <code>Diff</code> 算法是其虚拟 <code>DOM</code> 实现的核心，<code>Vue 3</code> 在这方面做了显著的优化。下面这个表格汇总了它们在核心机制和优化策略上的主要区别：</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性维度</th><th style="text-align:left;">Vue 2 🟢</th><th style="text-align:left;">Vue 3 🔵</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>核心算法</strong></td><td style="text-align:left;"><strong>双端比较</strong> ：通过四个指针（旧前、旧后、新前、新后）进行比较</td><td style="text-align:left;"><strong>增强的双端比较 + 最长递增子序列</strong> ：预处理后，利用最长递增子序列算法最小化移动操作</td></tr><tr><td style="text-align:left;"><strong>优化策略</strong></td><td style="text-align:left;"><strong>全量比较</strong> ：无论节点是否变化，每次更新都会进行创建和比较</td><td style="text-align:left;"><strong>编译时优化</strong> ：在编译阶段标记动态内容，实现<strong>静态提升</strong>、<strong>Patch Flag</strong>、<strong>事件缓存</strong>等</td></tr><tr><td style="text-align:left;"><strong>PatchFlag</strong></td><td style="text-align:left;">无</td><td style="text-align:left;"><strong>有</strong> ：在虚拟<code>DOM</code>节点上标记动态绑定的类型，实现<strong>精准定点更新</strong></td></tr><tr><td style="text-align:left;"><strong>静态提升</strong></td><td style="text-align:left;">无</td><td style="text-align:left;"><strong>有</strong> ：将静态节点提升到渲染函数之外，<strong>只创建一次，多次复用</strong></td></tr><tr><td style="text-align:left;"><strong>事件缓存</strong></td><td style="text-align:left;">无</td><td style="text-align:left;"><strong>有</strong> ：缓存不会变化的事件处理器，避免不必要的更新检查</td></tr><tr><td style="text-align:left;"><strong>Block Tree</strong></td><td style="text-align:left;">无</td><td style="text-align:left;"><strong>有</strong> ：将动态节点组织为树结构，减少比较范围</td></tr><tr><td style="text-align:left;"><strong>Fragment支持</strong></td><td style="text-align:left;">不支持（单根节点）</td><td style="text-align:left;"><strong>支持</strong>（多根节点），减少不必要的包装元素</td></tr></tbody></table><h3 id="🔎-核心算法原理与差异" tabindex="-1">🔎 核心算法原理与差异 <a class="header-anchor" href="#🔎-核心算法原理与差异" aria-label="Permalink to &quot;🔎 核心算法原理与差异&quot;">​</a></h3><br><p><strong><code>Vue 2</code> 的双端 <code>Diff</code> 算法</strong> 像是从列表的<strong>两端向中间</strong>进行比对 。它设置了四个指针（旧前、旧后、新前、新后），通过四种假设性的对比（如旧前对新前、旧后对新后等）来尝试查找可复用的节点 。这种方式在常见的操作，比如<strong>头尾部的增删</strong>中，表现不错。但它的核心局限在于，它采用的是一种 <strong>&quot;全量比较&quot;</strong> 的策略 ，即使模板中大部分内容是静态的，每次更新时仍然需要遍历和比较所有的虚拟 <code>DOM</code> 节点。</p><p><strong><code>Vue 3</code> 的增强 <code>Diff</code> 算法</strong> 则更加智能化，它结合了编译时优化和更高效的运行时算法：</p><ol><li><p><strong>Patch Flag：精准的更新提示</strong><br> 这是 <code>Vue 3</code> 的一项关键优化。在编译阶段，<code>Vue 3</code> 会分析模板，并在包含<strong>动态绑定</strong>的虚拟 <code>DOM</code> 节点上打上一个名为 <code>PatchFlag</code> 的数字标记 。这个标记指明了这个节点具体哪些内容是动态的，比如是文本、<code>class</code> 还是<code>props</code>。这样，在后续的 <code>Diff</code> 过程中，算法可以<strong>直接跳过那些完全没有标记的静态节点</strong>，只关注这些带有标记的动态节点，并且只更新标记所对应的特定内容 。</p></li><li><p><strong>最长递增子序列：最小化节点移动</strong><br> 在处理列表更新，特别是节点顺序发生变化时，<code>Vue 3</code> 会使用 <strong>&quot;最长递增子序列&quot;</strong> 算法来寻找新旧子节点列表中<strong>相对位置没有发生变化的最长节点序列</strong> 。找到这个序列后，<code>Vue 3</code> 就知道了哪些节点是稳定不需要移动的，然后只会去移动那些<strong>不在这个序列中的、真正需要移动的节点</strong> 。这极大地减少了 <code>DOM</code> 移动操作次数。有测试表明，在处理列表乱序或完全反转等场景时，<code>Vue 3</code> 因移动节点次数更少，性能表现优于 <code>Vue 2</code> 和 <code>React</code>。</p></li></ol><h3 id="💎-性能影响与升级价值" tabindex="-1">💎 性能影响与升级价值 <a class="header-anchor" href="#💎-性能影响与升级价值" aria-label="Permalink to &quot;💎 性能影响与升级价值&quot;">​</a></h3><br><p><code>Vue 3</code> 在 <code>Diff</code> 算法上的这一系列改进，使得它在<strong>处理大型应用或频繁更新的列表时，性能通常优于 <code>Vue 2</code></strong> 。这主要得益于其减少了不必要的虚拟节点比较和 <code>DOM</code> 操作次数 ，并且优化了内存使用 。</p><h2 id="vue-中父子组件的生命周期执行顺序" tabindex="-1">Vue 中父子组件的生命周期执行顺序 <a class="header-anchor" href="#vue-中父子组件的生命周期执行顺序" aria-label="Permalink to &quot;Vue 中父子组件的生命周期执行顺序&quot;">​</a></h2><p>在 <code>Vue2</code> 和 <code>Vue3</code> 中，父子组件的生命周期执行顺序基本一致，主要区别在于部分钩子名称的变化（如卸载阶段的钩子）。</p><h3 id="vue2-生命周期执行顺序" tabindex="-1"><strong><code>Vue2</code> 生命周期执行顺序</strong> <a class="header-anchor" href="#vue2-生命周期执行顺序" aria-label="Permalink to &quot;**`Vue2` 生命周期执行顺序**&quot;">​</a></h3><ol><li><p><strong>加载阶段</strong></p><ul><li>父组件：<code>beforeCreate</code> → <code>created</code> → <code>beforeMount</code></li><li>子组件：<code>beforeCreate</code> → <code>created</code> → <code>beforeMount</code> → <code>mounted</code></li><li>父组件：<code>mounted</code></li></ul></li><li><p><strong>更新阶段</strong>（父组件数据变化触发子组件更新时）</p><ul><li>父组件：<code>beforeUpdate</code></li><li>子组件：<code>beforeUpdate</code> → <code>updated</code></li><li>父组件：<code>updated</code></li></ul></li><li><p><strong>卸载阶段</strong></p><ul><li>父组件：<code>beforeDestroy</code></li><li>子组件：<code>beforeDestroy</code> → <code>destroyed</code></li><li>父组件：<code>destroyed</code></li></ul></li></ol><h3 id="vue3-生命周期执行顺序" tabindex="-1"><strong>Vue3 生命周期执行顺序</strong> <a class="header-anchor" href="#vue3-生命周期执行顺序" aria-label="Permalink to &quot;**Vue3 生命周期执行顺序**&quot;">​</a></h3><ol><li><p><strong>加载阶段</strong></p><ul><li>父组件：<code>beforeCreate</code> → <code>created</code> → <code>beforeMount</code></li><li>子组件：<code>beforeCreate</code> → <code>created</code> → <code>beforeMount</code> → <code>mounted</code></li><li>父组件：<code>mounted</code></li></ul><p><em>（注意：<code>Vue3</code>中可通过<code>setup()</code>替代<code>beforeCreate</code>和<code>created</code>，但执行顺序不变）</em></p></li><li><p><strong>更新阶段</strong></p><ul><li>父组件：<code>beforeUpdate</code></li><li>子组件：<code>beforeUpdate</code> → <code>updated</code></li><li>父组件：<code>updated</code></li></ul></li><li><p><strong>卸载阶段</strong></p><ul><li>父组件：<code>beforeUnmount</code></li><li>子组件：<code>beforeUnmount</code> → <code>unmounted</code></li><li>父组件：<code>unmounted</code></li></ul></li></ol><h3 id="关键区别" tabindex="-1"><strong>关键区别</strong> <a class="header-anchor" href="#关键区别" aria-label="Permalink to &quot;**关键区别**&quot;">​</a></h3><ol><li><p><strong>钩子名称变化</strong></p><ul><li><code>Vue2</code> 的 <code>beforeDestroy</code> 和 <code>destroyed</code> 在 <code>Vue3</code> 中更名为 <code>beforeUnmount</code> 和 <code>unmounted</code>。</li></ul></li><li><p><strong>Composition API 的影响</strong></p><ul><li><code>Vue3</code> 的 <code>setup()</code> 函数在 <code>beforeCreate</code> 之前执行，但不影响父子组件的执行顺序逻辑。</li></ul></li></ol><h3 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>挂载顺序</strong>：父组件初始化 → 子组件挂载 → 父组件完成挂载。</li><li><strong>更新顺序</strong>：父组件触发更新 → 子组件更新 → 父组件完成更新。</li><li><strong>卸载顺序</strong>：父组件开始卸载 → 子组件卸载 → 父组件完成卸载。</li></ul><p><code>Vue2</code> 和 <code>Vue3</code> 的差异仅体现在钩子命名上，核心执行逻辑保持一致。</p>',121))])}const f=t(h,[["render",c]]);export{b as __pageData,f as default};
