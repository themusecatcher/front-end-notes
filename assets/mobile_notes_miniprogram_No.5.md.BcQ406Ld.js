import{_ as d,C as t,c as i,o as c,j as e,G as l,ac as n,a as r}from"./chunks/framework.CtEZafqV.js";const s="/front-end-notes/assets/6f1ce9685dbcb7a8.D2WytLL7.jpg",g="/front-end-notes/assets/6f1ce9685dbcb7a8.D2WytLL7.jpg",q=JSON.parse('{"title":"Taro3 & Vue3 & typescript & less","description":"","frontmatter":{},"headers":[],"relativePath":"mobile/notes/miniprogram/No.5.md","filePath":"mobile/notes/miniprogram/No.5.md","lastUpdated":1762410823000}'),h={name:"mobile/notes/miniprogram/No.5.md"};function u(b,o,p,m,S,f){const a=t("BackTop");return c(),i("div",null,[o[0]||(o[0]=e("h1",{id:"taro3-vue3-typescript-less",tabindex:"-1"},[e("code",null,"Taro3"),r(" & "),e("code",null,"Vue3"),r(" & "),e("code",null,"typescript"),r(" & "),e("code",null,"less"),r(),e("a",{class:"header-anchor",href:"#taro3-vue3-typescript-less","aria-label":'Permalink to "`Taro3` & `Vue3` & `typescript` & `less`"'},"​")],-1)),l(a),o[1]||(o[1]=n('<h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://taro.zone/" target="_blank" rel="noreferrer">Taro官网</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noreferrer">微信官方文档</a></li><li><a href="https://mp.weixin.qq.com/" target="_blank" rel="noreferrer">微信公众平台</a></li><li><a href="https://nutui.jd.com/taro/vue/4x/#/zh-CN/guide/start" target="_blank" rel="noreferrer">Nut UI</a></li></ul><h2 id="微信小程序的双线程" tabindex="-1">微信小程序的双线程 <a class="header-anchor" href="#微信小程序的双线程" aria-label="Permalink to &quot;微信小程序的双线程&quot;">​</a></h2><p>微信小程序的双线程架构是其核心设计之一，旨在平衡性能、安全性和开发效率。以下是其关键要点：</p><h3 id="一、双线程架构的结构" tabindex="-1">一、双线程架构的结构 <a class="header-anchor" href="#一、双线程架构的结构" aria-label="Permalink to &quot;一、双线程架构的结构&quot;">​</a></h3><br><p>微信小程序将<strong>逻辑层</strong>（业务逻辑处理）与<strong>渲染层</strong>（界面渲染）分离，分别运行在两个独立的线程中：</p><ol><li><strong>逻辑层</strong></li></ol><ul><li>运行于独立的 <code>JsCore</code> 或 <code>V8</code> 引擎中，负责处理 <code>JavaScript</code> 代码（如事件响应、数据管理、网络请求等）。</li><li>逻辑层代码通过沙箱环境执行，无法直接操作 <code>DOM</code> 或调用浏览器 <code>API</code>，仅能通过微信提供的接口与 <code>Native</code> 层交互。</li></ul><ol start="2"><li><strong>渲染层</strong></li></ol><ul><li>基于 <code>WebView</code>（如 <code>Android</code> 的 <code>Chromium</code> 内核、<code>iOS</code> 的 <code>WKWebView</code>），负责将 <code>WXML</code> 和 <code>WXSS</code> 转换为真实 <code>DOM</code> 并渲染界面。</li><li>每个页面独立运行在单独的 <code>WebView</code> 线程中，避免多页面间的性能干扰</li></ul><h3 id="二、双线程通信机制" tabindex="-1">二、双线程通信机制 <a class="header-anchor" href="#二、双线程通信机制" aria-label="Permalink to &quot;二、双线程通信机制&quot;">​</a></h3><br><p>逻辑层与渲染层通过 <code>Native</code>（微信客户端） 中转实现通信：</p><ol><li><strong>数据传递</strong></li></ol><ul><li>逻辑层通过 <code>setData</code> 方法将数据序列化为字符串，经 <code>Native</code> 转发至渲染层。</li><li>渲染层接收数据后，通过虚拟 <code>DOM</code> 的 <code>diff</code> 算法更新真实 <code>DOM</code>，实现局部渲染。</li></ul><ol start="2"><li><strong>事件处理</strong></li></ol><ul><li>用户触发的界面事件（如点击）由渲染层捕获，经 <code>Native</code> 转发至逻辑层处理。</li></ul><ol start="3"><li><strong>开发者工具中的实现</strong></li></ol><ul><li>在真机中通过 <code>WeixinJSBridge</code> 实现通信，开发者工具则通过 <code>WebSocket</code> 模拟这一过程</li></ul><h3 id="三、双线程设计的原因" tabindex="-1">三、双线程设计的原因 <a class="header-anchor" href="#三、双线程设计的原因" aria-label="Permalink to &quot;三、双线程设计的原因&quot;">​</a></h3><ol><li><strong>安全性</strong></li></ol><ul><li>逻辑层与渲染层隔离，禁止直接操作 <code>DOM</code>，有效防止 <code>XSS</code> 攻击和敏感数据泄露。</li></ul><ol start="2"><li><strong>性能优化</strong></li></ol><ul><li>避免单线程中 <code>JavaScript</code> 执行与 <code>UI</code> 渲染的竞争，减少因脚本阻塞导致的卡顿问题。</li></ul><ol start="3"><li><strong>管控能力</strong></li></ol><ul><li>限制开发者使用浏览器开放接口（如动态脚本执行），通过沙箱环境强制代码规范。</li></ul><ol start="4"><li><strong>类原生体验</strong></li></ol><ul><li>通过 <code>Native</code> 组件（如地图、相机）与 <code>Web</code> 技术结合，提升交互流畅性。</li></ul><h3 id="四、双线程的优缺点" tabindex="-1">四、双线程的优缺点 <a class="header-anchor" href="#四、双线程的优缺点" aria-label="Permalink to &quot;四、双线程的优缺点&quot;">​</a></h3><ol><li><strong>优点</strong></li></ol><ul><li>安全性高：逻辑层无法直接操作 <code>DOM</code>，减少攻击面。</li><li>状态共享：所有页面逻辑运行在单一线程，便于全局状态管理（如 <code>Redux</code>）。</li><li>跨平台一致性：通过 <code>Native</code> 中转适配不同系统的 <code>WebView</code>，确保多端表现一致。</li></ul><ol start="2"><li><strong>缺点</strong></li></ol><ul><li>通信开销：频繁的线程间通信可能导致性能瓶颈，尤其在复杂交互场景（如长列表滚动）。</li><li>延迟问题：数据需经 <code>Native</code> 序列化与反序列化，增加响应延迟。</li><li>开发限制：无法直接使用浏览器 <code>API</code>，部分功能需依赖微信封装的组件。</li></ul><h3 id="五、与-web-单线程模型的对比" tabindex="-1">五、与 Web 单线程模型的对比 <a class="header-anchor" href="#五、与-web-单线程模型的对比" aria-label="Permalink to &quot;五、与 Web 单线程模型的对比&quot;">​</a></h3><br><p>传统 <code>Web</code> 页面中，<code>JavaScript</code> 与 <code>UI</code> 渲染共享同一线程，长时间脚本会阻塞渲染。 而小程序的双线程设计通过以下方式优化：</p><ul><li>线程隔离：逻辑层脚本阻塞时，渲染层仍可响应用户滚动等有限交互</li><li>虚拟 <code>DOM</code> 优化：通过 <code>diff</code> 算法减少不必要的 <code>DOM</code> 操作，提升渲染效率</li></ul><h2 id="taro-中的-jsbridge" tabindex="-1"><code>Taro</code> 中的 <code>JSBridge</code> <a class="header-anchor" href="#taro-中的-jsbridge" aria-label="Permalink to &quot;`Taro` 中的 `JSBridge`&quot;">​</a></h2><ul><li><a href="https://docs.taro.zone/blog/2020-01-02-gmtc#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8E%A2%E7%B4%A2" target="_blank" rel="noreferrer">参考文档</a></li></ul><p>微信小程序主要分为 <strong>逻辑层</strong> 和 <strong>视图层</strong>，以及在他们之下的原生部分。逻辑层主要负责 <code>JS</code> 运行，视图层主要负责页面的渲染，它们之间主要通过 <code>Event</code> 和 <code>Data</code> 进行通信，同时通过 <code>JSBridge</code> 调用原生的 <code>API</code>。这也是以微信小程序为首的大多数小程序的架构。</p><br><p><img src="'+s+'" alt="alt text"></p><br><p>由于原生部分对于前端开发者来说就像是一个黑盒，因此，整个架构图的原生部分可以省略。同时，我们对 <strong>逻辑层</strong> 和 <strong>视图层</strong> 也做一下简化，最后可以得到小程序架构图的极简版：</p><br><p><img src="'+g+'" alt="alt text"></p><br><p>也就是说，只需要在逻辑层调用对应的 <code>App()</code>/<code>Page()</code> 方法，且在方法里面处理 <code>data</code>、提供生命周期/事件函数等，同时在视图层提供对应的模版及样式供渲染就能运行小程序了。这也是大多数小程序开发框架重点考虑和处理的部分。</p><p><code>Taro</code> 框架中的 <code>JSBridge</code> 是实现跨端开发的核心技术之一，它通过构建 <code>JavaScript</code> 与原生环境之间的通信通道，解决多端适配问题。以下从原理、实现机制、应用场景等方面详细解析：</p><h3 id="一、jsbridge-的核心作用" tabindex="-1">一、<code>JSBridge</code> 的核心作用 <a class="header-anchor" href="#一、jsbridge-的核心作用" aria-label="Permalink to &quot;一、`JSBridge` 的核心作用&quot;">​</a></h3><br><p><code>JSBridge</code> 是 <strong>JavaScript 与 Native 代码双向通信的桥梁</strong>，主要功能包括：</p><ol><li><strong>JavaScript 调用 Native</strong>：访问摄像头、地理位置、支付等原生功能。</li><li><strong>Native 调用 JavaScript</strong>：传递回调结果、推送消息或状态更新。</li><li><strong>跨端适配</strong>：统一不同平台（如微信、支付宝小程序）的 <code>API</code> 差异，实现代码复用。</li></ol><h3 id="二、taro-中-jsbridge-的实现原理" tabindex="-1">二、<code>Taro</code> 中 <code>JSBridge</code> 的实现原理 <a class="header-anchor" href="#二、taro-中-jsbridge-的实现原理" aria-label="Permalink to &quot;二、`Taro` 中 `JSBridge` 的实现原理&quot;">​</a></h3><h4 id="_1-基于-webview-和-jsbridge-的运行时架构" tabindex="-1">1. <strong>基于 WebView 和 JSBridge 的运行时架构</strong> <a class="header-anchor" href="#_1-基于-webview-和-jsbridge-的运行时架构" aria-label="Permalink to &quot;1. **基于 WebView 和 JSBridge 的运行时架构**&quot;">​</a></h4><ul><li><strong>WebView 渲染层</strong>：<code>Taro</code> 将 <code>React/Vue</code> 代码编译为标准 <code>Web</code> 代码，由 <code>WebView</code> 渲染页面。</li><li><strong>JSBridge 通信层</strong>：通过注入全局对象或拦截 <code>URL Scheme</code>，实现 <code>JavaScript</code> 与原生环境的交互。</li></ul><h4 id="_2-双向通信机制" tabindex="-1">2. <strong>双向通信机制</strong> <a class="header-anchor" href="#_2-双向通信机制" aria-label="Permalink to &quot;2. **双向通信机制**&quot;">​</a></h4><ul><li><strong>JavaScript → Native</strong>： <ul><li><strong>注入 API</strong>：通过 <code>WebView</code> 接口（如 <code>addJavascriptInterface</code>）向全局对象注入 <code>Native</code> 方法，前端直接调用（如 <code>Taro.navigateTo</code>）。</li><li><strong>拦截 URL Scheme</strong>：前端通过 <code>iframe.src</code> 发送自定义协议请求（如 <code>jsbridge://showToast</code>），<code>Native</code> 拦截并解析执行对应逻辑。</li></ul></li><li><strong>Native → JavaScript</strong>：直接执行拼接的 <code>JavaScript</code> 代码（如 <code>evaluateJavaScript</code>），要求目标方法挂载在全局 <code>window</code> 上。</li></ul><h4 id="_3-消息管理与回调处理" tabindex="-1">3. <strong>消息管理与回调处理</strong> <a class="header-anchor" href="#_3-消息管理与回调处理" aria-label="Permalink to &quot;3. **消息管理与回调处理**&quot;">​</a></h4><ul><li><strong>RPC 模型</strong>：将每次通信视为远程过程调用（<code>RPC</code>），前端发送请求时生成唯一 <code>ID</code>，<code>Native</code> 处理完成后通过 <code>ID</code> 匹配回调。</li><li><strong>JSONP 机制</strong>：通过全局回调函数处理异步结果，例如将回调函数暂存于 <code>window</code>，<code>Native</code> 执行后触发。</li></ul><h3 id="三、taro-中-jsbridge-的跨端适配策略" tabindex="-1">三、<code>Taro</code> 中 <code>JSBridge</code> 的跨端适配策略 <a class="header-anchor" href="#三、taro-中-jsbridge-的跨端适配策略" aria-label="Permalink to &quot;三、`Taro` 中 `JSBridge` 的跨端适配策略&quot;">​</a></h3><ol><li><p><strong>统一 API 设计</strong>：</p><ul><li><code>Taro</code> 封装了各平台小程序的原生 <code>API</code>（如 <code>wx.request</code>、<code>my.alert</code>），提供统一的调用接口（如 <code>Taro.request</code>）。</li><li>运行时根据当前平台动态切换底层实现。</li></ul></li><li><p><strong>组件与生命周期映射</strong>：</p><ul><li>将 <code>React/Vue</code> 生命周期（如 <code>componentDidMount</code>）映射到小程序生命周期（如 <code>onLoad</code>、<code>onShow</code>）。</li><li>通过 <code>JSBridge</code> 同步状态，例如页面显示/隐藏时触发 <code>componentDidShow</code> 或 <code>componentDidHide</code>。</li></ul></li><li><p><strong>多端差异化处理</strong>：</p><ul><li>针对不同平台的特性（如微信的 <code>openSetting</code>、支付宝的 <code>getAuthCode</code>），在 <code>JSBridge</code> 层做兼容性封装。</li><li>例如，调用 <code>Taro.getLocation</code> 时，<code>JSBridge</code> 自动适配微信的 <code>wx.getLocation</code> 或支付宝的 <code>my.getLocation</code>。</li></ul></li></ol><h3 id="四、jsbridge-在-taro-中的优势与局限性" tabindex="-1">四、<code>JSBridge</code> 在 <code>Taro</code> 中的优势与局限性 <a class="header-anchor" href="#四、jsbridge-在-taro-中的优势与局限性" aria-label="Permalink to &quot;四、`JSBridge` 在 `Taro` 中的优势与局限性&quot;">​</a></h3><h4 id="优势" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;**优势**：&quot;">​</a></h4><ul><li><strong>跨端适配性强</strong>：一套代码适配微信、支付宝、百度等小程序及 <code>H5</code>、<code>React Native</code>。</li><li><strong>开发效率高</strong>：避免重复编写多端逻辑，减少维护成本。</li><li><strong>性能优化</strong>：通过预编译和运行时优化，降低通信开销（如减少 <code>URL Scheme</code> 拦截频率）。</li></ul><h4 id="局限性" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;**局限性**：&quot;">​</a></h4><ul><li><strong>平台特性差异</strong>：部分原生功能（如微信小程序的订阅消息）需单独处理。</li><li><strong>通信性能瓶颈</strong>：频繁的 <code>JavaScript-Native</code> 调用可能影响流畅度，需合理设计通信频率。</li></ul><h3 id="五、实际应用案例" tabindex="-1">五、实际应用案例 <a class="header-anchor" href="#五、实际应用案例" aria-label="Permalink to &quot;五、实际应用案例&quot;">​</a></h3><ol><li><strong>饿了么小程序</strong>：通过 <code>Taro</code> 实现多端统一，<code>JSBridge</code> 处理订单、支付等原生功能调用。</li><li><strong>网易云音乐小程序</strong>：利用 <code>JSBridge</code> 同步播放状态，跨端保持一致的音频控制逻辑。</li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>Taro</code> 的 <code>JSBridge</code> 通过 <strong>WebView 渲染+原生通信</strong> 的架构，结合 <strong>API 注入、URL 拦截、RPC 回调</strong> 等机制，实现了高效的跨端开发。其核心价值在于屏蔽底层差异，让开发者专注于业务逻辑，同时通过运行时适配保障多端一致性。实际开发中需注意平台特性与性能优化，以充分发挥其优势。</p>',72))])}const J=d(h,[["render",u]]);export{q as __pageData,J as default};
